static char *print_object( cJSON *item, int depth, int fmt )
 {
	char **entries = 0, **names = 0;
	char *out = 0, *ptr, *ret, *str;
	int len = 7, i = 0, j;
	cJSON *child = item->child;
	int numentries = 0, fail = 0;
 	
	while ( child ) {
		++numentries;
		child = child->next;
	}
	
	if ( ! ( entries = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) )
		return 0;
	if ( ! ( names = (char**) cJSON_malloc( numentries * sizeof(char*) ) ) ) {
		cJSON_free( entries );
		return 0;
	}
	memset( entries, 0, sizeof(char*) * numentries );
	memset( names, 0, sizeof(char*) * numentries );
	
	child = item->child;
	++depth;
	if ( fmt )
		len += depth;
	while ( child ) {
		names[i] = str = print_string_ptr( child->string );
		entries[i++] = ret = print_value( child, depth, fmt );
		if ( str && ret )
			len += strlen( ret ) + strlen( str ) + 2 + ( fmt ? 2 + depth : 0 );
		else
			fail = 1;
		child = child->next;
	}
	
	if ( ! fail ) {
		out = (char*) cJSON_malloc( len );
		if ( ! out )
			fail = 1;
	}
	
	if ( fail ) {
		for ( i = 0; i < numentries; ++i ) {
			if ( names[i] )
				cJSON_free( names[i] );
			if ( entries[i] )
				cJSON_free( entries[i] );
 		}
		cJSON_free( names );
		cJSON_free( entries );
		return 0;
 	}
	
	*out = '{';
	ptr = out + 1;
	if ( fmt )
		*ptr++ = '\n';
	*ptr = 0;
	for ( i = 0; i < numentries; ++i ) {
		if ( fmt )
			for ( j = 0; j < depth; ++j )
				*ptr++ = '\t';
		strcpy( ptr, names[i] );
		ptr += strlen( names[i] );
		*ptr++ = ':';
		if ( fmt )
			*ptr++ = '\t';
		strcpy( ptr, entries[i] );
		ptr += strlen( entries[i] );
		if ( i != numentries - 1 )
			*ptr++ = ',';
		if ( fmt )
			*ptr++ = '\n';
		*ptr = 0;
		cJSON_free( names[i] );
		cJSON_free( entries[i] );
 	}
	cJSON_free( names );
	cJSON_free( entries );
	if ( fmt )
		for ( i = 0; i < depth - 1; ++i )
			*ptr++ = '\t';
	*ptr++ = '}';
	*ptr++ = 0;
 	return out;	
 }