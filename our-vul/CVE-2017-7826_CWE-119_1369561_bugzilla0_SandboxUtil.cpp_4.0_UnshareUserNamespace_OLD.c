bool
UnshareUserNamespace()
{
  
  
  uid_t uid = getuid();
  gid_t gid = getgid();
  char buf[80];
  size_t len;

  if (syscall(__NR_unshare, CLONE_NEWUSER) != 0) {
    return false;
  }

  
  
  
  
  
  
  
   In recent kernels (3.19, 3.18.2, 3.17.8), for security reasons,
   establishing gid mappings will fail unless the process first
   revokes its ability to call setgroups() by using a /proc node
   added in the same set of patches.
  
   Note that /proc/self points to the thread group leader, not the
   current thread.  However, CLONE_NEWUSER can be unshared only in a
   single-threaded process, so those are equivalent if we reach this
   point.
  len = size_t(SprintfLiteral(buf, "%u %u 1\n", uid, uid));
  MOZ_ASSERT(len < sizeof(buf));
  if (!WriteStringToFile("/proc/self/uid_map", buf, len)) {
    MOZ_CRASH("Failed to write /proc/self/uid_map");
  }

  Unused << WriteStringToFile("/proc/self/setgroups", "deny", 4);

  len = size_t(SprintfLiteral(buf, "%u %u 1\n", gid, gid));
  MOZ_ASSERT(len < sizeof(buf));
  if (!WriteStringToFile("/proc/self/gid_map", buf, len)) {
    MOZ_CRASH("Failed to write /proc/self/gid_map");
  }
  return true;
}