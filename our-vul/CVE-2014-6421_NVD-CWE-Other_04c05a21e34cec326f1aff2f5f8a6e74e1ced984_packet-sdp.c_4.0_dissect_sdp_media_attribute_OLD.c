static void dissect_sdp_media_attribute(tvbuff_t *tvb, packet_info *pinfo, proto_item * ti, int length,
                                        transport_info_t *transport_info, disposable_media_info_t *media_info) {
    proto_tree *sdp_media_attribute_tree, *parameter_item;
    proto_item *fmtp_item, *media_format_item, *parameter_tree;
    proto_tree *fmtp_tree;
    gint        offset, next_offset, tokenlen, n, colon_offset;
    
    guint8     *payload_type;
    guint8     *attribute_value;
    gint       *key;
    guint8      pt;
    gint        sdp_media_attrbute_code;
    const char *msrp_res           = "msrp://";
    const char *h324ext_h223lcparm = "h324ext/h223lcparm";
    gboolean    has_more_pars      = TRUE;
    tvbuff_t   *h245_tvb;
    guint8      master_key_length  = 0, master_salt_length = 0;
    encoding_name_and_rate_t *encoding_name_and_rate;

    offset = 0;

    
    sdp_media_attribute_tree = proto_item_add_subtree(ti,
                                                      ett_sdp_media_attribute);
    
    colon_offset = tvb_find_guint8(tvb, offset, -1, ':');

    if (colon_offset == -1)
      return;

    
    tokenlen = colon_offset - offset;
    proto_tree_add_item(sdp_media_attribute_tree,
                        hf_media_attribute_field,
                        tvb, offset, tokenlen, ENC_UTF_8|ENC_NA);
    
    sdp_media_attrbute_code = find_sdp_media_attribute_names(tvb, offset, tokenlen);

    
    offset = colon_offset + 1;
    
    offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));

    
    attribute_value = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, tvb_length_remaining(tvb, offset), ENC_UTF_8|ENC_NA);



    
    

    switch (sdp_media_attrbute_code) {
        case SDP_RTPMAP:
            
            next_offset = tvb_find_guint8(tvb, offset, -1, ' ');

            if (next_offset == -1)
                return;

            tokenlen = next_offset - offset;

            proto_tree_add_item(sdp_media_attribute_tree, hf_media_format, tvb,
                                offset, tokenlen, ENC_UTF_8|ENC_NA);

            payload_type = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, tokenlen, ENC_UTF_8|ENC_NA);

            offset = next_offset + 1;

            next_offset = tvb_find_guint8(tvb, offset, -1, '/');

            if (next_offset == -1) {
                return;
            }

            tokenlen = next_offset - offset;

            proto_tree_add_item(sdp_media_attribute_tree, hf_media_encoding_name, tvb,
                                offset, tokenlen, ENC_UTF_8|ENC_NA);

            pt = atoi((char*)payload_type);
            if (pt >= SDP_NO_OF_PT) {
                return;   
            }

            key  = wmem_new(wmem_file_scope(), gint);
            *key = (gint)strtol((char*)payload_type, NULL, 10);

            transport_info->encoding_name[pt] = (char*)tvb_get_string_enc(wmem_packet_scope(), tvb, offset, tokenlen, ENC_UTF_8|ENC_NA);

            next_offset =  next_offset + 1;
            offset = next_offset;
            while (length-1 >= next_offset) {
                if (!g_ascii_isdigit(tvb_get_guint8(tvb, next_offset)))
                    break;
                next_offset++;
            }
            tokenlen = next_offset - offset;
            proto_tree_add_item(sdp_media_attribute_tree, hf_media_sample_rate, tvb,
                                offset, tokenlen, ENC_UTF_8|ENC_NA);
            transport_info->sample_rate[pt] = atoi(tvb_get_string_enc(wmem_packet_scope(), tvb, offset, tokenlen, ENC_UTF_8|ENC_NA));
            













            


            if (transport_info->media_count < 0) {
                for (n = 0; n < SDP_MAX_RTP_CHANNELS; n++) {
                    encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);
                    encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), transport_info->encoding_name[pt]);
                    encoding_name_and_rate->sample_rate = transport_info->sample_rate[pt];
                    if (n == 0) {
                        g_hash_table_insert(transport_info->media[n].rtp_dyn_payload,
                                            key, encoding_name_and_rate);
                    } else {    
                        gint *key2;
                        key2  = wmem_new(wmem_file_scope(), gint);
                        *key2 = (gint)strtol((char*)payload_type, NULL, 10);
                        g_hash_table_insert(transport_info->media[n].rtp_dyn_payload,
                                            key2, encoding_name_and_rate);
                    }
                }
                return;
                
            } else
                
                encoding_name_and_rate = wmem_new(wmem_file_scope(), encoding_name_and_rate_t);

            encoding_name_and_rate->encoding_name = wmem_strdup(wmem_file_scope(), transport_info->encoding_name[pt]);
            encoding_name_and_rate->sample_rate   = transport_info->sample_rate[pt];
            g_hash_table_insert(transport_info->media[ transport_info->media_count ].rtp_dyn_payload,
                                  key, encoding_name_and_rate);
            break;
        case SDP_FMTP:
            if (sdp_media_attribute_tree) {
                guint8 media_format;
                
                
                offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));
                
                next_offset = tvb_find_guint8(tvb, offset, -1, ' ');

                if (next_offset == -1)
                    return;

                tokenlen = next_offset - offset;


                media_format_item = proto_tree_add_item(sdp_media_attribute_tree,
                                                        hf_media_format, tvb, offset,
                                                        tokenlen, ENC_UTF_8|ENC_NA);
                media_format = atoi((char*)tvb_get_string_enc(wmem_packet_scope(), tvb, offset, tokenlen, ENC_UTF_8|ENC_NA));
                if (media_format >= SDP_NO_OF_PT) {
                    return;   
                }

                
                proto_item_append_text(media_format_item, " [%s]",
                                       transport_info->encoding_name[media_format]);

#if 0 
                payload_type = tvb_get_string(wmem_packet_scope(), tvb, offset, tokenlen);
#endif
                
                offset = next_offset + 1;

                while (has_more_pars == TRUE) {
                    next_offset = tvb_find_guint8(tvb, offset, -1, ';');
                    offset = tvb_skip_wsp(tvb, offset, tvb_length_remaining(tvb, offset));

                    if (next_offset == -1) {
                        has_more_pars = FALSE;
                        next_offset= tvb_length(tvb);
                    }

                    
                    tokenlen = next_offset - offset;
                    fmtp_item = proto_tree_add_item(sdp_media_attribute_tree,
                                                    hf_media_format_specific_parameter, tvb,
                                                    offset, tokenlen, ENC_UTF_8|ENC_NA);

                    fmtp_tree = proto_item_add_subtree(fmtp_item, ett_sdp_fmtp);

                    decode_sdp_fmtp(fmtp_tree, tvb, pinfo, offset, tokenlen,
                                    transport_info->encoding_name[media_format]);

                    
                    offset = next_offset + 1;
                }
            }
            break;
        case SDP_PATH:
            
            














            
            if (strncmp((char*)attribute_value, msrp_res, strlen(msrp_res)) == 0) {
                int address_offset, port_offset, port_end_offset;

                
                address_offset = offset + (int)strlen(msrp_res);

                
                port_offset = tvb_find_guint8(tvb, address_offset, -1, ':');
                
                if (port_offset!= -1) {
                    
                    port_end_offset = tvb_find_guint8(tvb, port_offset, -1, '/');
                    if (port_end_offset == -1) {
                        
                        port_end_offset = tvb_find_guint8(tvb, port_offset, -1, ';');
                    }
                    
                    if (str_to_ip((char*)tvb_get_string_enc(wmem_packet_scope(), tvb, address_offset, port_offset-address_offset, ENC_UTF_8|ENC_NA),
                                   &media_info->msrp_ipaddr)) {
                        
                        media_info->msrp_port_number = atoi((char*)tvb_get_string_enc(wmem_packet_scope(), tvb, port_offset + 1, port_end_offset - port_offset - 1, ENC_UTF_8|ENC_NA));
                        
                        media_info->msrp_transport_address_set = TRUE;
                    }
                }
            }
            break;
        case SDP_H248_ITEM:
            
            if (strncmp((char*)attribute_value, h324ext_h223lcparm, strlen(msrp_res)) == 0) {
                





                gint len;
                asn1_ctx_t actx;

                len = (gint)strlen(attribute_value);
                h245_tvb = ascii_bytes_to_tvb(tvb, pinfo, len, attribute_value);
                
                


                if (h245_tvb) {
                    asn1_ctx_init(&actx, ASN1_ENC_PER, TRUE, pinfo);
                    dissect_h245_H223LogicalChannelParameters(h245_tvb, 0, &actx,
                                                              sdp_media_attribute_tree,
                                                              hf_SDPh223LogicalChannelParameters);
                }
            }
            break;
        case SDP_CRYPTO:
            






















            
            
            next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
            if (next_offset==-1) {
                
                return;
            }
            tokenlen    = next_offset - offset;
            proto_tree_add_uint(sdp_media_attribute_tree, hf_sdp_crypto_tag, tvb, offset, tokenlen,
                atoi((char*)tvb_get_string_enc(wmem_packet_scope(), tvb, offset, tokenlen, ENC_UTF_8|ENC_NA)));
            offset = next_offset + 1;

            
            next_offset = tvb_find_guint8(tvb, offset, -1, ' ');
            if (next_offset==-1) {
                
                return;
            }
            tokenlen    = next_offset - offset;
            parameter_item = proto_tree_add_item(sdp_media_attribute_tree, hf_sdp_crypto_crypto_suite,
                tvb, offset, tokenlen, ENC_UTF_8|ENC_NA);
            if (tvb_strncaseeql(tvb, offset, "AES_CM_128_HMAC_SHA1_80", tokenlen) == 0) {

                
                if (transport_info->encryption_algorithm == SRTP_ENC_ALG_NOT_SET) {
                    transport_info->encryption_algorithm = SRTP_ENC_ALG_AES_CM;
                    transport_info->auth_algorithm       = SRTP_AUTH_ALG_HMAC_SHA1;
                    
                    transport_info->auth_tag_len         = 10;
                }
                master_key_length  = 16; 
                master_salt_length = 14; 
            } else if (tvb_strncaseeql(tvb, offset, "AES_CM_128_HMAC_SHA1_32", tokenlen) == 0) {
                
                if (transport_info->encryption_algorithm == SRTP_ENC_ALG_NOT_SET) {
                    transport_info->encryption_algorithm = SRTP_ENC_ALG_AES_CM;
                    transport_info->auth_algorithm       = SRTP_AUTH_ALG_HMAC_SHA1;
                    
                    transport_info->auth_tag_len         = 4;
                }
                master_key_length  = 16; 
                master_salt_length = 14; 
            } else if (tvb_strncaseeql(tvb, offset, "F8_128_HMAC_SHA1_80", tokenlen) == 0) {
                if (transport_info->encryption_algorithm == SRTP_ENC_ALG_NOT_SET) {
                    
                    transport_info->encryption_algorithm = SRTP_ENC_ALG_AES_F8;
                    transport_info->auth_algorithm       = SRTP_AUTH_ALG_HMAC_SHA1;
                    
                    transport_info->auth_tag_len         = 10;
                }
                master_key_length  = 16; 
                master_salt_length = 14; 
            }
            offset = next_offset + 1;

            
            while (has_more_pars == TRUE) {
                int       param_end_offset;
                tvbuff_t *key_salt_tvb;
                gchar    *data_p = NULL;

                param_end_offset = tvb_find_guint8(tvb, offset, -1, ';');
                if (param_end_offset == -1) {
                    has_more_pars = FALSE;
                    param_end_offset = tvb_length(tvb);
                }
                
                next_offset = tvb_find_guint8(tvb, offset, -1, ':');
                if (next_offset == -1) {
                    expert_add_info(pinfo, parameter_item, &ei_sdp_invalid_key_param);
                    break;
                }

                if (tvb_strncaseeql(tvb, offset, "inline", next_offset-offset) == 0) {
                    parameter_item = proto_tree_add_text(sdp_media_attribute_tree,
                        tvb, offset, param_end_offset-offset, "Key parameters");
                    parameter_tree = proto_item_add_subtree(parameter_item, ett_sdp_crypto_key_parameters);
                    
                    
                    offset      = next_offset +1;
                    next_offset = tvb_find_guint8(tvb, offset, -1, '|');
                    if (next_offset == -1) {
                        tokenlen = param_end_offset - offset;
                    } else {
                        tokenlen = next_offset - offset;
                    }
                    data_p = tvb_get_string_enc(wmem_packet_scope(), tvb, offset, tokenlen, ENC_UTF_8|ENC_NA);
                    key_salt_tvb = base64_to_tvb(tvb, data_p);
                    add_new_data_source(pinfo, key_salt_tvb, "Key_Salt_tvb");
                    if (master_key_length != 0) {
                        proto_tree_add_text(parameter_tree, tvb, offset, tokenlen, "Key and Salt");
                        proto_tree_add_item(parameter_tree, hf_sdp_crypto_master_key,
                            key_salt_tvb, 0, master_key_length, ENC_UTF_8|ENC_NA);
                        proto_tree_add_item(parameter_tree, hf_sdp_crypto_master_salt,
                            key_salt_tvb, master_key_length, master_salt_length, ENC_UTF_8|ENC_NA);
                    } else {
                        proto_tree_add_text(parameter_tree, key_salt_tvb, 0, -1, "Key and Salt");
                    }

                    
                    if (next_offset != -1) {
                        offset = next_offset + 1;
                        next_offset = tvb_find_guint8(tvb, offset, -1, '|');
                        if (next_offset == -1) {
                            if (next_offset < param_end_offset){
                                next_offset = param_end_offset;
                            }
                        }
                        if (next_offset != -1) {
                            
                            tokenlen = next_offset - offset;
                            proto_tree_add_item(parameter_tree, hf_sdp_crypto_lifetime,
                                tvb, offset, tokenlen, ENC_UTF_8|ENC_NA);
                            offset   = next_offset + 1;
                        }
                        



                        if (offset>param_end_offset) {
                            next_offset = -1;
                        } else {
                            next_offset = tvb_find_guint8(tvb, offset, -1, ':');
                        }
                        if (next_offset != -1) {
                            tokenlen    = next_offset - offset;
                            proto_tree_add_item(parameter_tree, hf_sdp_crypto_mki, tvb, offset, tokenlen, ENC_UTF_8|ENC_NA);
                            offset      = next_offset + 1;

                            
                            next_offset = param_end_offset;
                            tokenlen    = next_offset - offset;

                            
                            
                            transport_info->mki_len = atoi((char*)tvb_get_string_enc(wmem_packet_scope(), tvb, offset, tokenlen, ENC_UTF_8|ENC_NA));
                            proto_tree_add_item(parameter_tree, hf_sdp_crypto_mki_length,
                                tvb, offset, tokenlen, ENC_UTF_8|ENC_NA);
                        }
                    }
                    offset = param_end_offset;
                } else {
                    break;
                }
            }

          break;
        default:
            
            proto_tree_add_item(sdp_media_attribute_tree, hf_media_attribute_value,
                                tvb, offset, -1, ENC_UTF_8|ENC_NA);
            break;
    }
}