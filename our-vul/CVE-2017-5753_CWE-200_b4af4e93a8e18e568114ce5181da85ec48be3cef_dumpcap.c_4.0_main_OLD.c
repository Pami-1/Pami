int
main(int argc, char *argv[])
{
    GString          *comp_info_str;
    GString          *runtime_info_str;
    int               opt;
    static const struct option long_options[] = {
        {"help", no_argument, NULL, 'h'},
        {"version", no_argument, NULL, 'v'},
        LONGOPT_CAPTURE_COMMON
        {0, 0, 0, 0 }
    };

    gboolean          arg_error             = FALSE;

#ifdef _WIN32
    WSADATA           wsaData;
#else
    struct sigaction  action, oldaction;
#endif

    gboolean          start_capture         = TRUE;
    gboolean          stats_known;
    struct pcap_stat  stats;
    GLogLevelFlags    log_flags;
    gboolean          list_interfaces       = FALSE;
    gboolean          list_link_layer_types = FALSE;
#ifdef HAVE_BPF_IMAGE
    gboolean          print_bpf_code        = FALSE;
#endif
    gboolean          set_chan              = FALSE;
    gchar            *set_chan_arg          = NULL;
    gboolean          machine_readable      = FALSE;
    gboolean          print_statistics      = FALSE;
    int               status, run_once_args = 0;
    gint              i;
    guint             j;
#if defined(__APPLE__) && defined(__LP64__)
    struct utsname    osinfo;
#endif
    GString          *str;

    cmdarg_err_init(dumpcap_cmdarg_err, dumpcap_cmdarg_err_cont);

    
    comp_info_str = get_compiled_version_info(NULL, get_dumpcap_compiled_info);

    
    runtime_info_str = get_runtime_version_info(get_dumpcap_runtime_info);

    
    ws_add_crash_info("Dumpcap (Wireshark) %s\n"
           "\n"
           "%s"
           "\n"
           "%s",
        get_ws_vcs_version_info(), comp_info_str->str, runtime_info_str->str);
    g_string_free(comp_info_str, TRUE);
    g_string_free(runtime_info_str, TRUE);

#ifdef _WIN32
    arg_list_utf_16to8(argc, argv);
    create_app_running_mutex();

    



    ws_init_dll_search_path();
#endif

#ifdef HAVE_BPF_IMAGE
#define OPTSTRING_d "d"
#else
#define OPTSTRING_d ""
#endif

#ifdef HAVE_PCAP_REMOTE
#define OPTSTRING_r "r"
#define OPTSTRING_u "u"
#else
#define OPTSTRING_r ""
#define OPTSTRING_u ""
#endif

#ifdef HAVE_PCAP_SETSAMPLING
#define OPTSTRING_m "m:"
#else
#define OPTSTRING_m ""
#endif

#define OPTSTRING OPTSTRING_CAPTURE_COMMON "C:" OPTSTRING_d "gh" "k:" OPTSTRING_m "MN:nPq" OPTSTRING_r "St" OPTSTRING_u "vw:Z:"

#ifdef DEBUG_CHILD_DUMPCAP
    if ((debug_log = ws_fopen("dumpcap_debug_log.tmp","w")) == NULL) {
        fprintf (stderr, "Unable to open debug log file .\n");
        exit (1);
    }
#endif

#if defined(__APPLE__) && defined(__LP64__)
    







    if (uname(&osinfo) == 0) {
        




        if (strcmp(osinfo.release, "10.0.0") == 0 ||    
            strcmp(osinfo.release, "10.3.0") == 0 ||    
            strcmp(osinfo.release, "10.4.0") == 0)              
            need_timeout_workaround = TRUE;
    }
#endif

    

























    for (i=1; i<argc; i++) {
        if (strcmp("-Z", argv[i]) == 0) {
            capture_child    = TRUE;
            machine_readable = TRUE;  
#ifdef _WIN32
            
            _setmode(2, O_BINARY);
#endif
        }
    }

    
    
    
    
    
    

    log_flags =
        (GLogLevelFlags)(
        G_LOG_LEVEL_ERROR|
        G_LOG_LEVEL_CRITICAL|
        G_LOG_LEVEL_WARNING|
        G_LOG_LEVEL_MESSAGE|
        G_LOG_LEVEL_INFO|
        G_LOG_LEVEL_DEBUG|
        G_LOG_FLAG_FATAL|
        G_LOG_FLAG_RECURSION);

    g_log_set_handler(NULL,
                      log_flags,
                      console_log_handler, NULL );
    g_log_set_handler(LOG_DOMAIN_MAIN,
                      log_flags,
                      console_log_handler, NULL );
    g_log_set_handler(LOG_DOMAIN_CAPTURE,
                      log_flags,
                      console_log_handler, NULL );
    g_log_set_handler(LOG_DOMAIN_CAPTURE_CHILD,
                      log_flags,
                      console_log_handler, NULL );

    
    global_ld.pcaps = g_array_new(FALSE, FALSE, sizeof(capture_src *));

#if !GLIB_CHECK_VERSION(2,31,0)
    
    g_thread_init(NULL);
#endif

#ifdef _WIN32
    
    load_wpcap();

    
    
    

    
    WSAStartup( MAKEWORD( 1, 1 ), &wsaData );

    
    SetConsoleCtrlHandler(capture_cleanup_handler, TRUE);
#else
    











    memset(&action, 0, sizeof(action));
    action.sa_handler = capture_cleanup_handler;
    




    action.sa_flags = 0;
    sigemptyset(&action.sa_mask);
    sigaction(SIGTERM, &action, NULL);
    sigaction(SIGINT, &action, NULL);
    sigaction(SIGPIPE, &action, NULL);
    sigaction(SIGHUP, NULL, &oldaction);
    if (oldaction.sa_handler == SIG_DFL)
        sigaction(SIGHUP, &action, NULL);

#ifdef SIGINFO
    

    action.sa_handler = report_counts_siginfo;
    action.sa_flags = SA_RESTART;
    sigemptyset(&action.sa_mask);
    sigaction(SIGINFO, &action, NULL);
#endif 
#endif  

#ifdef __linux__
    enable_kernel_bpf_jit_compiler();
#endif

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    init_process_policies();

#ifdef HAVE_LIBCAP
    
    
    
    relinquish_privs_except_capture();
#endif

    

    capture_opts_init(&global_capture_opts);
    

    global_capture_opts.saving_to_file      = TRUE;
    global_capture_opts.has_ring_num_files  = TRUE;

    
    global_capture_opts.capture_child = capture_child;

    
    while ((opt = getopt_long(argc, argv, OPTSTRING, long_options, NULL)) != -1) {
        switch (opt) {
        case 'h':        
            printf("Dumpcap (Wireshark) %s\n"
                   "Capture network packets and dump them into a pcapng or pcap file.\n"
                   "See https://www.wireshark.org for more information.\n",
                   get_ws_vcs_version_info());
            print_usage(stdout);
            exit_main(0);
            break;
        case 'v':        
            comp_info_str = get_compiled_version_info(NULL, get_dumpcap_compiled_info);
            runtime_info_str = get_runtime_version_info(get_dumpcap_runtime_info);
            show_version("Dumpcap (Wireshark)", comp_info_str, runtime_info_str);
            g_string_free(comp_info_str, TRUE);
            g_string_free(runtime_info_str, TRUE);
            exit_main(0);
            break;
        
        case 'a':        
        case 'b':        
        case 'c':        
        case 'f':        
        case 'g':        
        case 'i':        
        case 'n':        
        case 'p':        
        case 'P':        
        case 's':        
        case 'w':        
        case 'y':        
        case  LONGOPT_NUM_CAP_COMMENT: 
#ifdef HAVE_PCAP_REMOTE
        case 'u':        
        case 'r':        
        case 'A':        
#endif
#ifdef HAVE_PCAP_SETSAMPLING
        case 'm':        
#endif
#ifdef CAN_SET_CAPTURE_BUFFER_SIZE
        case 'B':        
#endif
#ifdef HAVE_PCAP_CREATE
        case 'I':        
#endif
            status = capture_opts_add_opt(&global_capture_opts, opt, optarg, &start_capture);
            if (status != 0) {
                exit_main(status);
            }
            break;
            
        case 'Z':
            capture_child = TRUE;
#ifdef _WIN32
            
            _setmode(2, O_BINARY);
            



            if (strcmp(optarg, SIGNAL_PIPE_CTRL_ID_NONE) != 0) {
                sig_pipe_name = g_strdup_printf(SIGNAL_PIPE_FORMAT, optarg);
                sig_pipe_handle = CreateFile(utf_8to16(sig_pipe_name),
                                             GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);

                if (sig_pipe_handle == INVALID_HANDLE_VALUE) {
                    g_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_INFO,
                          "Signal pipe: Unable to open %s.  Dead parent?",
                          sig_pipe_name);
                    exit_main(1);
                }
            }
#endif
            break;

        case 'q':        
            quiet = TRUE;
            break;
        case 't':
            use_threads = TRUE;
            break;
            
        case 'D':        
            if (!list_interfaces) {
                list_interfaces = TRUE;
                run_once_args++;
            }
            break;
        case 'L':        
            if (!list_link_layer_types) {
                list_link_layer_types = TRUE;
                run_once_args++;
            }
            break;
#ifdef HAVE_BPF_IMAGE
        case 'd':        
            if (!print_bpf_code) {
                print_bpf_code = TRUE;
                run_once_args++;
            }
            break;
#endif
        case 'S':        
            if (!print_statistics) {
                print_statistics = TRUE;
                run_once_args++;
            }
            break;
        case 'k':        
            if (!set_chan) {
                set_chan = TRUE;
                set_chan_arg = optarg;
                run_once_args++;
            } else {
                cmdarg_err("Only one -k flag may be specified");
                arg_error = TRUE;
            }
            break;
        case 'M':        
            machine_readable = TRUE;
            break;
        case 'C':
            pcap_queue_byte_limit = get_positive_int(optarg, "byte_limit");
            break;
        case 'N':
            pcap_queue_packet_limit = get_positive_int(optarg, "packet_limit");
            break;
        default:
            cmdarg_err("Invalid Option: %s", argv[optind-1]);
            
        case '?':        
            arg_error = TRUE;
            break;
        }
    }
    if (!arg_error) {
        argc -= optind;
        argv += optind;
        if (argc >= 1) {
            
            
            argc--;
            argv++;
        }
        if (argc != 0) {
            



            cmdarg_err("Invalid argument: %s", argv[0]);
            arg_error = TRUE;
        }
    }

    if ((pcap_queue_byte_limit > 0) || (pcap_queue_packet_limit > 0)) {
        use_threads = TRUE;
    }
    if ((pcap_queue_byte_limit == 0) && (pcap_queue_packet_limit == 0)) {
        
        
        pcap_queue_byte_limit = 1000 * 1000;
        pcap_queue_packet_limit = 1000;
    }
    if (arg_error) {
        print_usage(stderr);
        exit_main(1);
    }

    if (run_once_args > 1) {
#ifdef HAVE_BPF_IMAGE
        cmdarg_err("Only one of -D, -L, -d, -k, or -S may be supplied.");
#else
        cmdarg_err("Only one of -D, -L, -k, or -S may be supplied.");
#endif
        exit_main(1);
    } else if (run_once_args == 1) {
        

        if (global_capture_opts.multi_files_on) {
            cmdarg_err("Ring buffer requested, but a capture isn't being done.");
            exit_main(1);
        }
    } else {
        

        
        if (global_capture_opts.ifaces->len > 1) {
            use_threads = TRUE;
            global_capture_opts.use_pcapng = TRUE;
        }

        if (global_capture_opts.capture_comment &&
            (!global_capture_opts.use_pcapng || global_capture_opts.multi_files_on)) {
            
            cmdarg_err("A capture comment can only be set if we capture into a single pcapng file.");
            exit_main(1);
        }

        
        if (global_capture_opts.multi_files_on) {
            



            if (global_capture_opts.save_file == NULL) {
                cmdarg_err("Ring buffer requested, but capture isn't being saved to a permanent file.");
                global_capture_opts.multi_files_on = FALSE;
            }
            if (!global_capture_opts.has_autostop_filesize && !global_capture_opts.has_file_duration) {
                cmdarg_err("Ring buffer requested, but no maximum capture file size or duration were specified.");
#if 0
                
                global_capture_opts.multi_files_on = FALSE;
#endif
            }
        }
    }

    



    if (list_interfaces) {
        
        GList *if_list;
        int    err;
        gchar *err_str;

        if_list = capture_interface_list(&err, &err_str,NULL);
        if (if_list == NULL) {
            if (err == 0) {
                





                if (!machine_readable) {
                    cmdarg_err("There are no interfaces on which a capture can be done");
                    exit_main(2);
                }
            } else {
                cmdarg_err("%s", err_str);
                g_free(err_str);
                exit_main(2);
            }
        }

        if (machine_readable)      
            print_machine_readable_interfaces(if_list);
        else
            capture_opts_print_interfaces(if_list);
        free_interface_list(if_list);
        exit_main(0);
    }

    



    if (print_statistics) {
        status = print_statistics_loop(machine_readable);
        exit_main(status);
    }

    if (set_chan) {
        interface_options interface_opts;

        if (global_capture_opts.ifaces->len != 1) {
            cmdarg_err("Need one interface");
            exit_main(2);
        }

        interface_opts = g_array_index(global_capture_opts.ifaces, interface_options, 0);
        status = set_80211_channel(interface_opts.name, set_chan_arg);
        exit_main(status);
    }

    



    status = capture_opts_default_iface_if_necessary(&global_capture_opts, NULL);
    if (status != 0) {
        
        exit_main(status);
    }

    if (list_link_layer_types) {
        
        if_capabilities_t *caps;
        gchar *err_str;
        guint  ii;

        for (ii = 0; ii < global_capture_opts.ifaces->len; ii++) {
            interface_options interface_opts;

            interface_opts = g_array_index(global_capture_opts.ifaces, interface_options, ii);

            caps = get_if_capabilities(&interface_opts, &err_str);
            if (caps == NULL) {
                cmdarg_err("The capabilities of the capture device \"%s\" could not be obtained (%s).\n"
                           "Please check to make sure you have sufficient permissions, and that\n"
                           "you have the proper interface or pipe specified.", interface_opts.name, err_str);
                g_free(err_str);
                exit_main(2);
            }
            if (caps->data_link_types == NULL) {
                cmdarg_err("The capture device \"%s\" has no data link types.", interface_opts.name);
                exit_main(2);
            }
            if (machine_readable)      
                
                print_machine_readable_if_capabilities(caps);
            else
                
                capture_opts_print_if_capabilities(caps, interface_opts.name,
                                                   interface_opts.monitor_mode);
            free_if_capabilities(caps);
        }
        exit_main(0);
    }

    

    
    if (capture_child) {
        for (j = 0; j < global_capture_opts.ifaces->len; j++) {
            interface_options interface_opts;

            interface_opts = g_array_index(global_capture_opts.ifaces, interface_options, j);
            g_log(LOG_DOMAIN_CAPTURE_CHILD, G_LOG_LEVEL_DEBUG, "Interface: %s\n",
                  interface_opts.name);
        }
    } else {
        str = g_string_new("");
#ifdef _WIN32
        if (global_capture_opts.ifaces->len < 2)
#else
        if (global_capture_opts.ifaces->len < 4)
#endif
        {
            for (j = 0; j < global_capture_opts.ifaces->len; j++) {
                interface_options interface_opts;

                interface_opts = g_array_index(global_capture_opts.ifaces, interface_options, j);
                if (j > 0) {
                    if (global_capture_opts.ifaces->len > 2) {
                        g_string_append_printf(str, ",");
                    }
                    g_string_append_printf(str, " ");
                    if (j == global_capture_opts.ifaces->len - 1) {
                        g_string_append_printf(str, "and ");
                    }
                }
                g_string_append_printf(str, "'%s'", interface_opts.console_display_name);
            }
        } else {
            g_string_append_printf(str, "%u interfaces", global_capture_opts.ifaces->len);
        }
        fprintf(stderr, "Capturing on %s\n", str->str);
        g_string_free(str, TRUE);
    }

    
    capture_opts_trim_snaplen(&global_capture_opts, MIN_PACKET_SIZE);

#ifdef HAVE_BPF_IMAGE
    if (print_bpf_code) {
        show_filter_code(&global_capture_opts);
        exit_main(0);
    }
#endif

    
    capture_opts_trim_ring_num_files(&global_capture_opts);

    
    fflush(stderr);

    
    if (capture_loop_start(&global_capture_opts, &stats_known, &stats) == TRUE) {
        
        exit_main(0);
    } else {
        
        exit_main(1);
    }
    return 0; 
}