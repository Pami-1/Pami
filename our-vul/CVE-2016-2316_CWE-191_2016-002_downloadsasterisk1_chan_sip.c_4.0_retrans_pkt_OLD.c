static int retrans_pkt(const void *data)
{
	struct sip_pkt *pkt = (struct sip_pkt *)data, *prev, *cur = NULL;
	int reschedule = DEFAULT_RETRANS;
	int xmitres = 0;
	
	int64_t diff = pkt->retrans_stop_time - ast_tvdiff_ms(ast_tvnow(), pkt->time_sent);

	


	if ((diff <= 0) || (diff > pkt->retrans_stop_time)) {
		pkt->retrans_stop = 1;
	}

	
	sip_pvt_lock(pkt->owner);

	if (!pkt->retrans_stop) {
		pkt->retrans++;
		if (!pkt->timer_t1) {	
			if (sipdebug) {
				ast_debug(4, "SIP TIMER: Not rescheduling id #%d:%s (Method %d) (No timer T1)\n",
					pkt->retransid,
					sip_methods[pkt->method].text,
					pkt->method);
			}
		} else {
			int siptimer_a;

			if (sipdebug) {
				ast_debug(4, "SIP TIMER: Rescheduling retransmission #%d (%d) %s - %d\n",
					pkt->retransid,
					pkt->retrans,
					sip_methods[pkt->method].text,
					pkt->method);
			}
			if (!pkt->timer_a) {
				pkt->timer_a = 2 ;
			} else {
				pkt->timer_a = 2 * pkt->timer_a;
			}

			
			siptimer_a = pkt->timer_t1 * pkt->timer_a;	
			if (pkt->method != SIP_INVITE && siptimer_a > 4000) {
				siptimer_a = 4000;
			}

			
			reschedule = siptimer_a;
			ast_debug(4, "** SIP timers: Rescheduling retransmission %d to %d ms (t1 %d ms (Retrans id #%d)) \n",
				pkt->retrans + 1,
				siptimer_a,
				pkt->timer_t1,
				pkt->retransid);
		}

		if (sip_debug_test_pvt(pkt->owner)) {
			const struct ast_sockaddr *dst = sip_real_dst(pkt->owner);
			ast_verbose("Retransmitting #%d (%s) to %s:\n%s\n---\n",
				pkt->retrans, sip_nat_mode(pkt->owner),
				ast_sockaddr_stringify(dst),
				ast_str_buffer(pkt->data));
		}

		append_history(pkt->owner, "ReTx", "%d %s", reschedule, ast_str_buffer(pkt->data));
		xmitres = __sip_xmit(pkt->owner, pkt->data);

		




		if (xmitres != XMIT_ERROR) {
			if (reschedule >= diff) {
				pkt->retrans_stop = 1;
				reschedule = diff;
			}
			sip_pvt_unlock(pkt->owner);
			return  reschedule;
		}
	}

	


	pkt->retransid = -1; 

	if (pkt->method != SIP_OPTIONS && xmitres == 0) {
		if (pkt->is_fatal || sipdebug) { 
			ast_log(LOG_WARNING, "Retransmission timeout reached on transmission %s for seqno %u (%s %s) -- See https://wiki.asterisk.org/wiki/display/AST/SIP+Retransmissions\n"
				"Packet timed out after %dms with no response\n",
				pkt->owner->callid,
				pkt->seqno,
				pkt->is_fatal ? "Critical" : "Non-critical",
				pkt->is_resp ? "Response" : "Request",
				(int) ast_tvdiff_ms(ast_tvnow(), pkt->time_sent));
		}
	} else if (pkt->method == SIP_OPTIONS && sipdebug) {
		ast_log(LOG_WARNING, "Cancelling retransmit of OPTIONs (call id %s)  -- See https://wiki.asterisk.org/wiki/display/AST/SIP+Retransmissions\n", pkt->owner->callid);
	}

	if (xmitres == XMIT_ERROR) {
		ast_log(LOG_WARNING, "Transmit error :: Cancelling transmission on Call ID %s\n", pkt->owner->callid);
		append_history(pkt->owner, "XmitErr", "%s", pkt->is_fatal ? "(Critical)" : "(Non-critical)");
	} else {
		append_history(pkt->owner, "MaxRetries", "%s", pkt->is_fatal ? "(Critical)" : "(Non-critical)");
	}

	if (pkt->is_fatal) {
		while(pkt->owner->owner && ast_channel_trylock(pkt->owner->owner)) {
			sip_pvt_unlock(pkt->owner);	
			usleep(1);
			sip_pvt_lock(pkt->owner);
		}
		if (pkt->owner->owner && !ast_channel_hangupcause(pkt->owner->owner)) {
			ast_channel_hangupcause_set(pkt->owner->owner, AST_CAUSE_NO_USER_RESPONSE);
		}
		if (pkt->owner->owner) {
			ast_log(LOG_WARNING, "Hanging up call %s - no reply to our critical packet (see https://wiki.asterisk.org/wiki/display/AST/SIP+Retransmissions).\n", pkt->owner->callid);

			if (pkt->is_resp &&
				(pkt->response_code >= 200) &&
				(pkt->response_code < 300) &&
				pkt->owner->pendinginvite &&
				ast_test_flag(&pkt->owner->flags[1], SIP_PAGE2_DIALOG_ESTABLISHED)) {
				






				pkt->owner->invitestate = INV_TERMINATED;
				pkt->owner->pendinginvite = 0;
			} else {
				
				sip_alreadygone(pkt->owner);
			}
			ast_queue_hangup_with_cause(pkt->owner->owner, AST_CAUSE_NO_USER_RESPONSE);
			ast_channel_unlock(pkt->owner->owner);
		} else {
			

			
			if (pkt->method != SIP_OPTIONS && pkt->method != SIP_REGISTER) {
				pvt_set_needdestroy(pkt->owner, "no response to critical packet");
				sip_alreadygone(pkt->owner);
				append_history(pkt->owner, "DialogKill", "Killing this failed dialog immediately");
			}
		}
	}

	if (pkt->method == SIP_BYE) {
		
		sip_alreadygone(pkt->owner);
		if (pkt->owner->owner) {
			ast_channel_unlock(pkt->owner->owner);
		}
		append_history(pkt->owner, "ByeFailure", "Remote peer doesn't respond to bye. Destroying call anyway.");
		pvt_set_needdestroy(pkt->owner, "no response to BYE");
	}

	
	for (prev = NULL, cur = pkt->owner->packets; cur; prev = cur, cur = cur->next) {
		if (cur == pkt) {
			UNLINK(cur, pkt->owner->packets, prev);
			sip_pvt_unlock(pkt->owner);
			if (pkt->owner) {
				pkt->owner = dialog_unref(pkt->owner,"pkt is being freed, its dialog ref is dead now");
			}
			if (pkt->data) {
				ast_free(pkt->data);
			}
			pkt->data = NULL;
			ast_free(pkt);
			return 0;
		}
	}
	
	ast_log(LOG_WARNING, "Weird, couldn't find packet owner!\n");
	sip_pvt_unlock(pkt->owner);
	return 0;
}