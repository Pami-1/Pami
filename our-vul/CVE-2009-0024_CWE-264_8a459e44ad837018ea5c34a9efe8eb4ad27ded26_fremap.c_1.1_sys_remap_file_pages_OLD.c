asmlinkage long sys_remap_file_pages(unsigned long start, unsigned long size,
	unsigned long prot, unsigned long pgoff, unsigned long flags)
{
	struct mm_struct *mm = current->mm;
	struct address_space *mapping;
	unsigned long end = start + size;
	struct vm_area_struct *vma;
	int err = -EINVAL;
	int has_write_lock = 0;

	if (prot)
		return err;
	


	start = start & PAGE_MASK;
	size = size & PAGE_MASK;

	
	if (start + size <= start)
		return err;

	
#if PTE_FILE_MAX_BITS < BITS_PER_LONG
	if (pgoff + (size >> PAGE_SHIFT) >= (1UL << PTE_FILE_MAX_BITS))
		return err;
#endif

	
	down_read(&mm->mmap_sem);
 retry:
	vma = find_vma(mm, start);

	





	if (!vma || !(vma->vm_flags & VM_SHARED))
		goto out;

	if (vma->vm_private_data && !(vma->vm_flags & VM_NONLINEAR))
		goto out;

	if (!(vma->vm_flags & VM_CAN_NONLINEAR))
		goto out;

	if (end <= start || start < vma->vm_start || end > vma->vm_end)
		goto out;

	
	if (!(vma->vm_flags & VM_NONLINEAR)) {
		
		if (pgoff == linear_page_index(vma, start)) {
			err = 0;
			goto out;
		}

		if (!has_write_lock) {
			up_read(&mm->mmap_sem);
			down_write(&mm->mmap_sem);
			has_write_lock = 1;
			goto retry;
		}
		mapping = vma->vm_file->f_mapping;
		




		if (mapping_cap_account_dirty(mapping)) {
			unsigned long addr;

			flags &= MAP_NONBLOCK;
			addr = mmap_region(vma->vm_file, start, size,
					flags, vma->vm_flags, pgoff, 1);
			if (IS_ERR_VALUE(addr)) {
				err = addr;
			} else {
				BUG_ON(addr != start);
				err = 0;
			}
			goto out;
		}
		spin_lock(&mapping->i_mmap_lock);
		flush_dcache_mmap_lock(mapping);
		vma->vm_flags |= VM_NONLINEAR;
		vma_prio_tree_remove(vma, &mapping->i_mmap);
		vma_nonlinear_insert(vma, &mapping->i_mmap_nonlinear);
		flush_dcache_mmap_unlock(mapping);
		spin_unlock(&mapping->i_mmap_lock);
	}

	err = populate_range(mm, vma, start, size, pgoff);
	if (!err && !(flags & MAP_NONBLOCK)) {
		if (unlikely(has_write_lock)) {
			downgrade_write(&mm->mmap_sem);
			has_write_lock = 0;
		}
		make_pages_present(start, start+size);
	}

	





out:
	if (likely(!has_write_lock))
		up_read(&mm->mmap_sem);
	else
		up_write(&mm->mmap_sem);

	return err;
}