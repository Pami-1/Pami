static int
ext4_ext_rm_leaf(handle_t *handle, struct inode *inode,
		struct ext4_ext_path *path, ext4_lblk_t start,
		ext4_lblk_t end)
{
	int err = 0, correct_index = 0;
	int depth = ext_depth(inode), credits;
	struct ext4_extent_header *eh;
	ext4_lblk_t a, b, block;
	unsigned num;
	ext4_lblk_t ex_ee_block;
	unsigned short ex_ee_len;
	unsigned uninitialized = 0;
	struct ext4_extent *ex;
	struct ext4_map_blocks map;

	
	ext_debug("truncate since %u in leaf\n", start);
	if (!path[depth].p_hdr)
		path[depth].p_hdr = ext_block_hdr(path[depth].p_bh);
	eh = path[depth].p_hdr;
	if (unlikely(path[depth].p_hdr == NULL)) {
		EXT4_ERROR_INODE(inode, "path[%d].p_hdr == NULL", depth);
		return -EIO;
	}
	
	ex = EXT_LAST_EXTENT(eh);

	ex_ee_block = le32_to_cpu(ex->ee_block);
	ex_ee_len = ext4_ext_get_actual_len(ex);

	while (ex >= EXT_FIRST_EXTENT(eh) &&
			ex_ee_block + ex_ee_len > start) {

		if (ext4_ext_is_uninitialized(ex))
			uninitialized = 1;
		else
			uninitialized = 0;

		ext_debug("remove ext %u:[%d]%d\n", ex_ee_block,
			 uninitialized, ex_ee_len);
		path[depth].p_ext = ex;

		a = ex_ee_block > start ? ex_ee_block : start;
		b = ex_ee_block+ex_ee_len - 1 < end ?
			ex_ee_block+ex_ee_len - 1 : end;

		ext_debug("  border %u:%u\n", a, b);

		
		if (end <= ex_ee_block) {
			ex--;
			ex_ee_block = le32_to_cpu(ex->ee_block);
			ex_ee_len = ext4_ext_get_actual_len(ex);
			continue;
		} else if (a != ex_ee_block &&
			b != ex_ee_block + ex_ee_len - 1) {
			




			if (end == EXT_MAX_BLOCK) {
				ext_debug("  bad truncate %u:%u\n",
						start, end);
				block = 0;
				num = 0;
				err = -EIO;
				goto out;
			}
			




			else{
				map.m_pblk = ext4_ext_pblock(ex);
				map.m_lblk = ex_ee_block;
				map.m_len = b - ex_ee_block;

				err = ext4_split_extent(handle,
					inode, path, &map, 0,
					EXT4_GET_BLOCKS_PUNCH_OUT_EXT |
					EXT4_GET_BLOCKS_PRE_IO);

				if (err < 0)
					goto out;

				ex_ee_len = ext4_ext_get_actual_len(ex);

				b = ex_ee_block+ex_ee_len - 1 < end ?
					ex_ee_block+ex_ee_len - 1 : end;

				
				block = ex_ee_block;
				num = a - block;
			}
		} else if (a != ex_ee_block) {
			
			block = ex_ee_block;
			num = a - block;
		} else if (b != ex_ee_block + ex_ee_len - 1) {
			
			block = b;
			num =  ex_ee_block + ex_ee_len - b;

			



			if (end == EXT_MAX_BLOCK) {
				ext_debug("  bad truncate %u:%u\n",
					start, end);
				err = -EIO;
				goto out;
			}
		} else {
			
			block = ex_ee_block;
			num = 0;
			if (a != ex_ee_block) {
				ext_debug("  bad truncate %u:%u\n",
					start, end);
				err = -EIO;
				goto out;
			}

			if (b != ex_ee_block + ex_ee_len - 1) {
				ext_debug("  bad truncate %u:%u\n",
					start, end);
				err = -EIO;
				goto out;
			}
		}

		





		credits = 7 + 2*(ex_ee_len/EXT4_BLOCKS_PER_GROUP(inode->i_sb));
		if (ex == EXT_FIRST_EXTENT(eh)) {
			correct_index = 1;
			credits += (ext_depth(inode)) + 1;
		}
		credits += EXT4_MAXQUOTAS_TRANS_BLOCKS(inode->i_sb);

		err = ext4_ext_truncate_extend_restart(handle, inode, credits);
		if (err)
			goto out;

		err = ext4_ext_get_access(handle, inode, path + depth);
		if (err)
			goto out;

		err = ext4_remove_blocks(handle, inode, ex, a, b);
		if (err)
			goto out;

		if (num == 0) {
			
			ext4_ext_store_pblock(ex, 0);
		} else if (block != ex_ee_block) {
			




			ext4_ext_store_pblock(ex, ext4_ext_pblock(ex) + (b-a));
		}

		ex->ee_block = cpu_to_le32(block);
		ex->ee_len = cpu_to_le16(num);
		



		if (uninitialized && num)
			ext4_ext_mark_uninitialized(ex);

		err = ext4_ext_dirty(handle, inode, path + depth);
		if (err)
			goto out;

		



		if (num == 0) {
			if (end != EXT_MAX_BLOCK) {
				




				memmove(ex, ex+1, (EXT_LAST_EXTENT(eh) - ex) *
					sizeof(struct ext4_extent));

				
				memset(EXT_LAST_EXTENT(eh), 0,
					sizeof(struct ext4_extent));
			}
			le16_add_cpu(&eh->eh_entries, -1);
		}

		ext_debug("new extent: %u:%u:%llu\n", block, num,
				ext4_ext_pblock(ex));
		ex--;
		ex_ee_block = le32_to_cpu(ex->ee_block);
		ex_ee_len = ext4_ext_get_actual_len(ex);
	}

	if (correct_index && eh->eh_entries)
		err = ext4_ext_correct_indexes(handle, inode, path);

	

	if (err == 0 && eh->eh_entries == 0 && path[depth].p_bh != NULL)
		err = ext4_ext_rm_idx(handle, inode, path + depth);

out:
	return err;
}