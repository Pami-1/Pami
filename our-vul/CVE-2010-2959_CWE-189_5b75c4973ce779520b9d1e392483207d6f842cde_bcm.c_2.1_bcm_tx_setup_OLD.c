static int bcm_tx_setup(struct bcm_msg_head *msg_head, struct msghdr *msg,
			int ifindex, struct sock *sk)
{
	struct bcm_sock *bo = bcm_sk(sk);
	struct bcm_op *op;
	int i, err;

	
	if (!ifindex)
		return -ENODEV;

	
	if (msg_head->nframes < 1)
		return -EINVAL;

	
	op = bcm_find_op(&bo->tx_ops, msg_head->can_id, ifindex);

	if (op) {
		

		




		if (msg_head->nframes > op->nframes)
			return -E2BIG;

		
		for (i = 0; i < msg_head->nframes; i++) {
			err = memcpy_fromiovec((u8 *)&op->frames[i],
					       msg->msg_iov, CFSIZ);

			if (op->frames[i].can_dlc > 8)
				err = -EINVAL;

			if (err < 0)
				return err;

			if (msg_head->flags & TX_CP_CAN_ID) {
				
				op->frames[i].can_id = msg_head->can_id;
			}
		}

	} else {
		

		op = kzalloc(OPSIZ, GFP_KERNEL);
		if (!op)
			return -ENOMEM;

		op->can_id    = msg_head->can_id;

		
		if (msg_head->nframes > 1) {
			op->frames = kmalloc(msg_head->nframes * CFSIZ,
					     GFP_KERNEL);
			if (!op->frames) {
				kfree(op);
				return -ENOMEM;
			}
		} else
			op->frames = &op->sframe;

		for (i = 0; i < msg_head->nframes; i++) {
			err = memcpy_fromiovec((u8 *)&op->frames[i],
					       msg->msg_iov, CFSIZ);

			if (op->frames[i].can_dlc > 8)
				err = -EINVAL;

			if (err < 0) {
				if (op->frames != &op->sframe)
					kfree(op->frames);
				kfree(op);
				return err;
			}

			if (msg_head->flags & TX_CP_CAN_ID) {
				
				op->frames[i].can_id = msg_head->can_id;
			}
		}

		
		op->last_frames = NULL;

		
		op->sk = sk;
		op->ifindex = ifindex;

		
		hrtimer_init(&op->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
		op->timer.function = bcm_tx_timeout_handler;

		
		tasklet_init(&op->tsklet, bcm_tx_timeout_tsklet,
			     (unsigned long) op);

		
		hrtimer_init(&op->thrtimer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);

		
		list_add(&op->list, &bo->tx_ops);

	} 

	if (op->nframes != msg_head->nframes) {
		op->nframes   = msg_head->nframes;
		
		op->currframe = 0;
	}

	

	op->flags = msg_head->flags;

	if (op->flags & TX_RESET_MULTI_IDX) {
		
		op->currframe = 0;
	}

	if (op->flags & SETTIMER) {
		
		op->count = msg_head->count;
		op->ival1 = msg_head->ival1;
		op->ival2 = msg_head->ival2;
		op->kt_ival1 = timeval_to_ktime(msg_head->ival1);
		op->kt_ival2 = timeval_to_ktime(msg_head->ival2);

		
		if (!op->kt_ival1.tv64 && !op->kt_ival2.tv64)
			hrtimer_cancel(&op->timer);
	}

	if ((op->flags & STARTTIMER) &&
	    ((op->kt_ival1.tv64 && op->count) || op->kt_ival2.tv64)) {

		
		op->flags |= TX_ANNOUNCE;

		if (op->kt_ival1.tv64 && (op->count > 0)) {
			
			hrtimer_start(&op->timer, op->kt_ival1,
				      HRTIMER_MODE_REL);
		} else
			hrtimer_start(&op->timer, op->kt_ival2,
				      HRTIMER_MODE_REL);
	}

	if (op->flags & TX_ANNOUNCE)
		bcm_can_tx(op);

	return msg_head->nframes * CFSIZ + MHSIZ;
}