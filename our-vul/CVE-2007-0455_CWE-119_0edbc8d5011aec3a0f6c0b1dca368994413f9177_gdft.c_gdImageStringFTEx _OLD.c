char *
gdImageStringFTEx (gdImage * im, int *brect, int fg, char *fontlist, double ptsize, double angle, int x, int y, char *string, gdFTStringExtraPtr strex)
{
	FT_BBox bbox, glyph_bbox;
	FT_Matrix matrix;
	FT_Vector pen, delta, penf;
	FT_Face face;
	FT_Glyph image;
	FT_GlyphSlot slot;
	FT_Bool use_kerning;
	FT_UInt glyph_index, previous;
	double sin_a = sin (angle);
	double cos_a = cos (angle);
	int len, i = 0, ch;
	int x1 = 0, y1 = 0;
	font_t *font;
	fontkey_t fontkey;
	char *next;
	char *tmpstr = NULL;
	int render = (im && (im->trueColor || (fg <= 255 && fg >= -255)));
	FT_BitmapGlyph bm;
	
	int render_mode = FT_LOAD_DEFAULT;
	int m, mfound;
	
	double linespace = LINESPACE;
	
	






	gdCache_head_t  *tc_cache;
	
	int hdpi, vdpi;

	if (strex && ((strex->flags & gdFTEX_LINESPACE) == gdFTEX_LINESPACE)) {
		linespace = strex->linespacing;
	}
	tc_cache = gdCacheCreate(TWEENCOLORCACHESIZE, tweenColorTest, tweenColorFetch, tweenColorRelease);

	

	if (!fontCache) {
		if (gdFontCacheSetup() != 0) {
			gdCacheDelete(tc_cache);
			return "Failure to initialize font library";
		}
	}
	
	
	gdMutexLock(gdFontCacheMutex);
	
	fontkey.fontlist = fontlist;
	fontkey.library = &library;
	font = (font_t *) gdCacheGet (fontCache, &fontkey);
	if (!font) {
		gdCacheDelete(tc_cache);
		gdMutexUnlock(gdFontCacheMutex);
		return fontCache->error;
	}
	face = font->face;		
	slot = face->glyph;		

	




	hdpi = GD_RESOLUTION;
	vdpi = GD_RESOLUTION;
	if (strex && (strex->flags & gdFTEX_RESOLUTION)) {
		hdpi = strex->hdpi;
		vdpi = strex->vdpi;
	}

	if (FT_Set_Char_Size(face, 0, (FT_F26Dot6) (ptsize * 64), hdpi, vdpi)) {
		gdCacheDelete(tc_cache);
		gdMutexUnlock(gdFontCacheMutex);
		return "Could not set character size";
	}

	matrix.xx = (FT_Fixed) (cos_a * (1 << 16));
	matrix.yx = (FT_Fixed) (sin_a * (1 << 16));
	matrix.xy = -matrix.yx;
	matrix.yy = matrix.xx;

	penf.x = penf.y = 0;		
	pen.x = pen.y = 0;		
	bbox.xMin = bbox.xMax = bbox.yMin = bbox.yMax = 0;

	use_kerning = FT_HAS_KERNING (face);
	previous = 0;
	if (fg < 0) {
		render_mode |= FT_LOAD_MONOCHROME;
	}
	


	m = gdFTEX_Unicode;
	if (strex && (strex->flags & gdFTEX_CHARMAP)) {
		m = strex->charmap;
	}
	
	mfound = 0;
	for (i = 0; i < 3; i++) {
		switch (m) {
			case gdFTEX_Unicode:
				if (font->have_char_map_unicode) {
					mfound = 1;
				}
				break;
			case gdFTEX_Shift_JIS:
				if (font->have_char_map_sjis) {
					mfound = 1;
				}
				break;
			case gdFTEX_Big5:
				
				mfound = 1;
				break;
		}
		if (mfound) {
			break;
		}
		m++;
		m %= 3;
	}
	if (!mfound) {
		
		gdMutexUnlock(gdFontCacheMutex);
		return "No character set found";
	}

#ifndef JISX0208
	if (font->have_char_map_sjis) {
#endif
		tmpstr = (char *) gdMalloc(BUFSIZ);
		any2eucjp(tmpstr, string, BUFSIZ);
		next = tmpstr;
#ifndef JISX0208
	} else {
		next = string;
	}
#endif

	while (*next) {
		ch = *next;
		
		if (ch == '\r') {
			penf.x = 0;
			x1 = (int)(penf.x * cos_a - penf.y * sin_a + 32) / 64;
			y1 = (int)(penf.x * sin_a + penf.y * cos_a + 32) / 64;
			pen.x = pen.y = 0;
			previous = 0;		
			next++;
			continue;
		}
		
		if (ch == '\n') {
			
			penf.x = 0;
			  penf.y -= (long)(face->size->metrics.height * linespace);
			  penf.y = (penf.y - 32) & -64;		
			  x1 = (int)(penf.x * cos_a - penf.y * sin_a + 32) / 64;
			  y1 = (int)(penf.x * sin_a + penf.y * cos_a + 32) / 64;
			  pen.x = pen.y = 0;
			  previous = 0;		
			  next++;
			  continue;
		}


#if (defined(FREETYPE_MAJOR) && ((FREETYPE_MAJOR == 2 && ((FREETYPE_MINOR == 1 && FREETYPE_PATCH >= 3) || FREETYPE_MINOR > 1) || FREETYPE_MAJOR > 2)))
		if (font->face->charmap->encoding == FT_ENCODING_MS_SYMBOL && strcmp(font->face->family_name, "Symbol") == 0) {
			



			 
			len = gdTcl_UtfToUniChar (next, &ch);
			ch |= 0xf000;
			next += len;
		} else
#endif 


		switch (m) {
			case gdFTEX_Unicode:
				if (font->have_char_map_unicode) {
					
					len = gdTcl_UtfToUniChar(next, &ch);
					next += len;
				}
				break;
			case gdFTEX_Shift_JIS: 
				if (font->have_char_map_sjis) {
					unsigned char c;
					int jiscode;
					c = *next;
					if (0xA1 <= c && c <= 0xFE) {
						next++;
						jiscode = 0x100 * (c & 0x7F) + ((*next) & 0x7F);

						ch = (jiscode >> 8) & 0xFF;
						jiscode &= 0xFF;

						if (ch & 1) {
							jiscode += 0x40 - 0x21;
						} else {
							jiscode += 0x9E - 0x21;
						}

						if (jiscode >= 0x7F) {
							jiscode++;
						}
						ch = (ch - 0x21) / 2 + 0x81;
						if (ch >= 0xA0) {
							ch += 0x40;
						}

						ch = (ch << 8) + jiscode;
					} else {
						ch = c & 0xFF;	
					}
					if (next) next++;
				}
				break;
			case gdFTEX_Big5: {
				




				ch = (*next) & 0xFF;	
				next++;
				if (ch >= 161	
					&& *next) { 
					
					ch = (ch * 256) + ((*next) & 255);
					next++;
				}
			}
			break;
		}

		
		FT_Set_Transform(face, &matrix, NULL);
		
		glyph_index = FT_Get_Char_Index(face, ch);
		
		
		if (use_kerning && previous && glyph_index) {
			FT_Get_Kerning(face, previous, glyph_index, ft_kerning_default, &delta);
			pen.x += delta.x;
			penf.x += delta.x;
		}

		
		if (FT_Load_Glyph(face, glyph_index, render_mode)) {
			if (tmpstr) {
				gdFree(tmpstr);
			}
			gdCacheDelete(tc_cache);
			gdMutexUnlock(gdFontCacheMutex);
			return "Problem loading glyph";
		}

		
		FT_Get_Glyph(slot, &image);
		if (brect) { 
			FT_Glyph_Get_CBox(image, ft_glyph_bbox_gridfit, &glyph_bbox);
			glyph_bbox.xMin += penf.x;
			glyph_bbox.yMin += penf.y;
			glyph_bbox.xMax += penf.x;
			glyph_bbox.yMax += penf.y;
			if (ch == ' ') { 
				glyph_bbox.xMax += slot->metrics.horiAdvance;
			}
			if (!i) { 
				bbox.xMin = glyph_bbox.xMin;
				bbox.yMin = glyph_bbox.yMin;
				bbox.xMax = glyph_bbox.xMax;
				bbox.yMax = glyph_bbox.yMax;
			} else {
				if (bbox.xMin > glyph_bbox.xMin) {
					bbox.xMin = glyph_bbox.xMin;
				}
				if (bbox.yMin > glyph_bbox.yMin) {
					bbox.yMin = glyph_bbox.yMin;
				}
				if (bbox.xMax < glyph_bbox.xMax) {
					bbox.xMax = glyph_bbox.xMax;
				}
				if (bbox.yMax < glyph_bbox.yMax) {
					bbox.yMax = glyph_bbox.yMax;
				}
			}
			i++;
		}

		if (render) {
			if (image->format != ft_glyph_format_bitmap && FT_Glyph_To_Bitmap(&image, ft_render_mode_normal, 0, 1)) {
				if (tmpstr) {
					gdFree(tmpstr);
				}
				gdCacheDelete(tc_cache);
				gdMutexUnlock(gdFontCacheMutex);
				return "Problem rendering glyph";
			}

			
			bm = (FT_BitmapGlyph) image;
			gdft_draw_bitmap(tc_cache, im, fg, bm->bitmap, x + x1 + ((pen.x + 31) >> 6) + bm->left, y - y1 + ((pen.y + 31) >> 6) - bm->top);
		}

		
		previous = glyph_index;

		
		pen.x += image->advance.x >> 10;
		pen.y -= image->advance.y >> 10;

		penf.x += slot->metrics.horiAdvance;

		FT_Done_Glyph(image);
	}

	if (brect) { 
		
		double d1 = sin (angle + 0.78539816339744830962);
		double d2 = sin (angle - 0.78539816339744830962);

		
		brect[0] = (int) (bbox.xMin * cos_a - bbox.yMin * sin_a);
		brect[1] = (int) (bbox.xMin * sin_a + bbox.yMin * cos_a);
		brect[2] = (int) (bbox.xMax * cos_a - bbox.yMin * sin_a);
		brect[3] = (int) (bbox.xMax * sin_a + bbox.yMin * cos_a);
		brect[4] = (int) (bbox.xMax * cos_a - bbox.yMax * sin_a);
		brect[5] = (int) (bbox.xMax * sin_a + bbox.yMax * cos_a);
		brect[6] = (int) (bbox.xMin * cos_a - bbox.yMax * sin_a);
		brect[7] = (int) (bbox.xMin * sin_a + bbox.yMax * cos_a);

		
		brect[0] = x + gdroundupdown(brect[0], d2 > 0);
		brect[1] = y - gdroundupdown(brect[1], d1 < 0);
		brect[2] = x + gdroundupdown(brect[2], d1 > 0);
		brect[3] = y - gdroundupdown(brect[3], d2 > 0);
		brect[4] = x + gdroundupdown(brect[4], d2 < 0);
		brect[5] = y - gdroundupdown(brect[5], d1 > 0);
		brect[6] = x + gdroundupdown(brect[6], d1 < 0);
		brect[7] = y - gdroundupdown(brect[7], d2 < 0);
	}

	if (tmpstr) {
		gdFree(tmpstr);
	}
	gdCacheDelete(tc_cache);
	gdMutexUnlock(gdFontCacheMutex);
	return (char *) NULL;
}