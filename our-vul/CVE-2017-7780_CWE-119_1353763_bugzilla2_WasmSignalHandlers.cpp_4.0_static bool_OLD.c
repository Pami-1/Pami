template<Signal signal>
static bool
HandleFault(int signum, siginfo_t* info, void* ctx)
{
    
    
    
    if (signal == Signal::SegFault)
        MOZ_RELEASE_ASSERT(signum == SIGSEGV);
    else
        MOZ_RELEASE_ASSERT(signum == SIGBUS);

    CONTEXT* context = (CONTEXT*)ctx;
    uint8_t** ppc = ContextToPC(context);
    uint8_t* pc = *ppc;

    
    JSContext* cx = TlsContext.get();
    if (!cx || cx->handlingSegFault)
        return false;
    AutoSetHandlingSegFault handling(cx);

    WasmActivation* activation = cx->wasmActivationStack();
    if (!activation)
        return false;

    const Instance* instance = LookupFaultingInstance(activation, pc, ContextToFP(context));
    if (!instance || !instance->codeSegment().containsFunctionPC(pc))
        return false;

    uint8_t* faultingAddress = reinterpret_cast<uint8_t*>(info->si_addr);

    
    
    
    if (!faultingAddress) {
        
        
        
        
#ifdef SI_KERNEL
        if (info->si_code != SI_KERNEL)
            return false;
#else
        return false;
#endif
    } else {
        if (!IsHeapAccessAddress(*instance, faultingAddress))
            return false;
    }

#ifdef JS_CODEGEN_ARM
    if (signal == Signal::BusError) {
        
        
        
        
        *ppc = instance->codeSegment().unalignedAccessCode();
        return true;
    }
#endif

    HandleMemoryAccess(context, pc, faultingAddress, *instance, ppc);
    return true;
}