gboolean
dissector_try_heuristic(heur_dissector_list_t sub_dissectors, tvbuff_t *tvb,
			packet_info *pinfo, proto_tree *tree, heur_dtbl_entry_t **heur_dtbl_entry, void *data)
{
	gboolean           status;
	const char        *saved_curr_proto;
	const char        *saved_heur_list_name;
	GSList            *entry;
	guint16            saved_can_desegment;
	guint              saved_layers_len = 0;
	heur_dtbl_entry_t *hdtbl_entry;
	int                proto_id;

	








	saved_can_desegment        = pinfo->can_desegment;
	pinfo->saved_can_desegment = saved_can_desegment;
	pinfo->can_desegment       = saved_can_desegment-(saved_can_desegment>0);

	status      = FALSE;
	saved_curr_proto = pinfo->current_proto;
	saved_heur_list_name = pinfo->heur_list_name;

	saved_layers_len = wmem_list_count(pinfo->layers);
	*heur_dtbl_entry = NULL;

	for (entry = sub_dissectors->dissectors; entry != NULL;
	    entry = g_slist_next(entry)) {
		
		pinfo->can_desegment = saved_can_desegment-(saved_can_desegment>0);
		hdtbl_entry = (heur_dtbl_entry_t *)entry->data;

		if (hdtbl_entry->protocol != NULL &&
			(!proto_is_protocol_enabled(hdtbl_entry->protocol)||(hdtbl_entry->enabled==FALSE))) {
			


			continue;
		}

		if (hdtbl_entry->protocol != NULL) {
			proto_id = proto_get_id(hdtbl_entry->protocol);
			

			pinfo->current_proto =
				proto_get_protocol_short_name(hdtbl_entry->protocol);

			



			wmem_list_append(pinfo->layers, GINT_TO_POINTER(proto_id));
		}

		pinfo->heur_list_name = hdtbl_entry->list_name;

		if ((hdtbl_entry->dissector)(tvb, pinfo, tree, data)) {
			*heur_dtbl_entry = hdtbl_entry;
			status = TRUE;
			break;
		} else {
			




			while (wmem_list_count(pinfo->layers) > saved_layers_len) {
				wmem_list_remove_frame(pinfo->layers, wmem_list_tail(pinfo->layers));
			}
		}
	}

	pinfo->current_proto = saved_curr_proto;
	pinfo->heur_list_name = saved_heur_list_name;
	pinfo->can_desegment = saved_can_desegment;
	return status;
}