static INT Dot11DecryptScanForKeys(
    PDOT11DECRYPT_CONTEXT ctx,
    const guint8 *data,
    const guint mac_header_len,
    const guint tot_len,
    DOT11DECRYPT_SEC_ASSOCIATION_ID id
)
{
    const UCHAR *addr;
    guint bodyLength;
    PDOT11DECRYPT_SEC_ASSOCIATION sta_sa;
    PDOT11DECRYPT_SEC_ASSOCIATION sa;
    guint offset = 0;
    const guint8 dot1x_header[] = {
        0xAA,             
        0xAA,             
        0x03,             
        0x00, 0x00, 0x00, 
        0x88, 0x8E        
    };
    const guint8 bt_dot1x_header[] = {
        0xAA,             
        0xAA,             
        0x03,             
        0x00, 0x19, 0x58, 
        0x00, 0x03        
    };
    const guint8 tdls_header[] = {
        0xAA,             
        0xAA,             
        0x03,             
        0x00, 0x00, 0x00, 
        0x89, 0x0D,       
        0x02,             
        0X0C              
    };

    const EAPOL_RSN_KEY *pEAPKey;
#ifdef DOT11DECRYPT_DEBUG
#define MSGBUF_LEN 255
    CHAR msgbuf[MSGBUF_LEN];
#endif
    DOT11DECRYPT_DEBUG_TRACE_START("Dot11DecryptScanForKeys");

    
    offset = mac_header_len;

    
    if (memcmp(data+offset, dot1x_header, 8) == 0 || memcmp(data+offset, bt_dot1x_header, 8) == 0) {

        DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", "Authentication: EAPOL packet", DOT11DECRYPT_DEBUG_LEVEL_3);

        
        offset+=8;

        
        if (data[offset+1]!=3) {
            DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", "Not EAPOL-Key", DOT11DECRYPT_DEBUG_LEVEL_3);
            return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;
        }

        
        bodyLength=pntoh16(data+offset+2);
        if (((tot_len-offset-4) < bodyLength) || (bodyLength < sizeof(EAPOL_RSN_KEY))) { 
            DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", "EAPOL body too short", DOT11DECRYPT_DEBUG_LEVEL_3);
            return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;
        }

        
        offset+=4;

        pEAPKey = (const EAPOL_RSN_KEY *) (data+offset);

        
        if ( 
            pEAPKey->type != DOT11DECRYPT_RSN_WPA2_KEY_DESCRIPTOR &&             
            pEAPKey->type != DOT11DECRYPT_RSN_WPA_KEY_DESCRIPTOR)           
        {
            DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", "Not valid key descriptor type", DOT11DECRYPT_DEBUG_LEVEL_3);
            return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;
        }

        
        offset+=1;

        
        sa = Dot11DecryptGetSaPtr(ctx, &id);
        if (sa == NULL){
            DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", "No SA for BSSID found", DOT11DECRYPT_DEBUG_LEVEL_3);
            return DOT11DECRYPT_RET_REQ_DATA;
        }

        
        if (Dot11DecryptRsna4WHandshake(ctx, data, sa, offset, tot_len) == DOT11DECRYPT_RET_SUCCESS_HANDSHAKE)
            return DOT11DECRYPT_RET_SUCCESS_HANDSHAKE;

        if (mac_header_len + GROUP_KEY_PAYLOAD_LEN_MIN > tot_len) {
            DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", "Message too short for Group Key", DOT11DECRYPT_DEBUG_LEVEL_3);
            return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;
        }

        
        if (DOT11DECRYPT_EAP_KEY(data[offset+1])!=0 ||
            DOT11DECRYPT_EAP_ACK(data[offset+1])!=1 ||
            DOT11DECRYPT_EAP_MIC(data[offset]) != 1 ||
            DOT11DECRYPT_EAP_SEC(data[offset]) != 1){

            DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", "Key bitfields not correct for Group Key", DOT11DECRYPT_DEBUG_LEVEL_3);
            return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;
        }

        
        memcpy(id.sta, broadcast_mac, DOT11DECRYPT_MAC_LEN);

        
        sa = Dot11DecryptGetSaPtr(ctx, &id);
        if (sa == NULL){
            return DOT11DECRYPT_RET_REQ_DATA;
        }

        

        
        if ( (addr=Dot11DecryptGetStaAddress((const DOT11DECRYPT_MAC_FRAME_ADDR4 *)(data))) != NULL) {
            memcpy(id.sta, addr, DOT11DECRYPT_MAC_LEN);
#ifdef DOT11DECRYPT_DEBUG
            g_snprintf(msgbuf, MSGBUF_LEN, "ST_MAC: %2X.%2X.%2X.%2X.%2X.%2X\t", id.sta[0],id.sta[1],id.sta[2],id.sta[3],id.sta[4],id.sta[5]);
#endif
            DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", msgbuf, DOT11DECRYPT_DEBUG_LEVEL_3);
        } else {
            DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", "SA not found", DOT11DECRYPT_DEBUG_LEVEL_5);
            return DOT11DECRYPT_RET_REQ_DATA;
        }

        sta_sa = Dot11DecryptGetSaPtr(ctx, &id);
        if (sta_sa == NULL){
            return DOT11DECRYPT_RET_REQ_DATA;
        }

        
        return (Dot11DecryptDecryptWPABroadcastKey(pEAPKey, sta_sa->wpa.ptk+16, sa, tot_len-offset+1));

    } else if (memcmp(data+offset, tdls_header, 10) == 0) {
        const guint8 *initiator, *responder;
        guint8 action;
        guint status, offset_rsne = 0, offset_fte = 0, offset_link = 0, offset_timeout = 0;
        DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", "Authentication: TDLS Action Frame", DOT11DECRYPT_DEBUG_LEVEL_3);

        
        offset+=10;

        
        action = data[offset];
        if (action!=1 && action!=2) {
            DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", "Not Response nor confirm", DOT11DECRYPT_DEBUG_LEVEL_3);
            return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;
        }

        
        offset++;
        status=pntoh16(data+offset);
        if (status!=0) {
            DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", "TDLS setup not successfull", DOT11DECRYPT_DEBUG_LEVEL_3);
            return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;
        }

        
        offset+=5;

        

        while(offset < (tot_len - 2)) {
            if (data[offset] == 48) {
                offset_rsne = offset;
            } else if (data[offset] == 55) {
                offset_fte = offset;
            } else if (data[offset] == 56) {
                offset_timeout = offset;
            } else if (data[offset] == 101) {
                offset_link = offset;
            }

            if (tot_len < offset + data[offset + 1] + 2) {
                return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;
            }
            offset += data[offset + 1] + 2;
        }

        if (offset_rsne == 0 || offset_fte == 0 ||
            offset_timeout == 0 || offset_link == 0)
        {
            DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", "Cannot Find all necessary IEs", DOT11DECRYPT_DEBUG_LEVEL_3);
            return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;
        }

        DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", "Found RSNE/Fast BSS/Timeout Interval/Link IEs", DOT11DECRYPT_DEBUG_LEVEL_3);

        
        initiator = &data[offset_link + 8];
        responder = &data[offset_link + 14];

        if (memcmp(initiator, responder, DOT11DECRYPT_MAC_LEN) < 0) {
            memcpy(id.sta, initiator, DOT11DECRYPT_MAC_LEN);
            memcpy(id.bssid, responder, DOT11DECRYPT_MAC_LEN);
        } else {
            memcpy(id.sta, responder, DOT11DECRYPT_MAC_LEN);
            memcpy(id.bssid, initiator, DOT11DECRYPT_MAC_LEN);
        }

        sa = Dot11DecryptGetSaPtr(ctx, &id);
        if (sa == NULL){
            return DOT11DECRYPT_RET_REQ_DATA;
        }

        if (sa->validKey) {
            if (memcmp(sa->wpa.nonce, data + offset_fte + 52, DOT11DECRYPT_WPA_NONCE_LEN) == 0) {
                
                return DOT11DECRYPT_RET_SUCCESS_HANDSHAKE;
            } else {
                
                DOT11DECRYPT_SEC_ASSOCIATION *tmp_sa = g_new(DOT11DECRYPT_SEC_ASSOCIATION, 1);
                memcpy(tmp_sa, sa, sizeof(DOT11DECRYPT_SEC_ASSOCIATION));
                sa->next=tmp_sa;
                sa->validKey = FALSE;
            }
        }

        if (Dot11DecryptTDLSDeriveKey(sa, data, offset_rsne, offset_fte, offset_timeout, offset_link, action)
            == DOT11DECRYPT_RET_SUCCESS) {
            DOT11DECRYPT_DEBUG_TRACE_END("Dot11DecryptScanForKeys");
            return DOT11DECRYPT_RET_SUCCESS_HANDSHAKE;
        }
    } else {
        DOT11DECRYPT_DEBUG_PRINT_LINE("Dot11DecryptScanForKeys", "Skipping: not an EAPOL packet", DOT11DECRYPT_DEBUG_LEVEL_3);
    }

    DOT11DECRYPT_DEBUG_TRACE_END("Dot11DecryptScanForKeys");
    return DOT11DECRYPT_RET_NO_VALID_HANDSHAKE;
}