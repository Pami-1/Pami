static fragment_head *
fragment_add_seq_check_work(reassembly_table *table, tvbuff_t *tvb,
			    const int offset, const packet_info *pinfo,
			    const guint32 id, const void *data,
			    const guint32 frag_number,
			    const guint32 frag_data_len,
			    const gboolean more_frags, const guint32 flags)
{
	reassembled_key reass_key;
	fragment_head *fd_head;
	gpointer orig_key;

	



	if (pinfo->fd->flags.visited) {
		reass_key.frame = pinfo->num;
		reass_key.id = id;
		return (fragment_head *)g_hash_table_lookup(table->reassembled_table, &reass_key);
	}

	fd_head = fragment_add_seq_common(table, tvb, offset, pinfo, id, data,
					  frag_number, frag_data_len,
					  more_frags,
					  flags|REASSEMBLE_FLAGS_CHECK_DATA_PRESENT,
					  &orig_key);
	if (fd_head) {
		if(fd_head->flags & FD_DATA_NOT_PRESENT) {
			


			return fd_head;
		}

		







		if (orig_key != NULL)
			fragment_unhash(table, orig_key);

		


		fragment_reassembled(table, fd_head, pinfo, id);
		return fd_head;
	} else {
		


		return NULL;
	}
}