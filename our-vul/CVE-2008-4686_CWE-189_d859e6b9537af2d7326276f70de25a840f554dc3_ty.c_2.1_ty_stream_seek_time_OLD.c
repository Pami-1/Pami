static int ty_stream_seek_time(demux_t *p_demux, uint64_t l_seek_time)
{
    demux_sys_t *p_sys = p_demux->p_sys;
    int i, i_seq_entry = 0;
    int i_skip_cnt;
    long l_cur_pos = stream_Tell(p_demux->s);
    int i_cur_part = l_cur_pos / TIVO_PART_LENGTH;
    long l_seek_secs = l_seek_time / 1000000000;
    uint64_t l_fwd_stamp = 1;

    
    if (!p_sys->b_seekable || !p_sys->b_have_master)
        return VLC_EGENERIC;

    msg_Dbg(p_demux, "Skipping to time %02ld:%02ld:%02ld",
            l_seek_secs / 3600, (l_seek_secs / 60) % 60, l_seek_secs % 60);

    
    
    while (l_seek_time < p_sys->l_first_ty_pts) {
        msg_Dbg(p_demux, "skipping to prior segment.");
        
        if (i_cur_part == 0) {
            stream_Seek(p_demux->s, l_cur_pos);
            msg_Err(p_demux, "Attempt to seek past BOF");
            return VLC_EGENERIC;
        }
        stream_Seek(p_demux->s, (i_cur_part - 1) * TIVO_PART_LENGTH);
        i_cur_part--;
        parse_master(p_demux);
    }
    
    while (l_seek_time > p_sys->l_final_ty_pts) {
        msg_Dbg(p_demux, "skipping to next segment.");
        
        if ((i_cur_part + 1) * TIVO_PART_LENGTH > p_sys->i_stream_size) {
            
            stream_Seek(p_demux->s, l_cur_pos);
            msg_Err(p_demux, "seek error");
            return VLC_EGENERIC;
        }
        stream_Seek(p_demux->s, (i_cur_part + 1) * TIVO_PART_LENGTH);
        i_cur_part++;
        parse_master(p_demux);
    }

    

    for (i=1; i<p_sys->i_seq_table_size; i++) {
        if (p_sys->seq_table[i].l_timestamp > l_seek_time) {
            


            msg_Dbg(p_demux, "stopping at seq entry %d.", i);
            l_fwd_stamp = p_sys->seq_table[i].l_timestamp;
            i_seq_entry = i-1;
            break;
        }
    }
    
    



    if (i == p_sys->i_seq_table_size) {
        if ((i_cur_part + 1) * TIVO_PART_LENGTH > p_sys->i_stream_size) {
            
            stream_Seek(p_demux->s, l_cur_pos);
            msg_Err(p_demux, "seek error");
            return VLC_EGENERIC;
        }
        stream_Seek(p_demux->s, (i_cur_part + 1) * TIVO_PART_LENGTH);
        i_cur_part++;
        parse_master(p_demux);
        i_seq_entry = 0;
    }     
     
    
    for (i=0; i<p_sys->i_bits_per_seq_entry; i++) {
        long l_chunk_nr = i_seq_entry * p_sys->i_bits_per_seq_entry + i;
        long l_chunk_offset = (l_chunk_nr + 1) * CHUNK_SIZE;
        msg_Dbg(p_demux, "testing part %d chunk %ld mask 0x%02X bit %d",
            i_cur_part, l_chunk_nr,
            p_sys->seq_table[i_seq_entry].chunk_bitmask[i/8], i%8);
        if (p_sys->seq_table[i_seq_entry].chunk_bitmask[i/8] & (1 << (i%8))) {
            
            msg_Dbg(p_demux, "has SEQ. seeking to chunk at 0x%lX",
                (i_cur_part * TIVO_PART_LENGTH) + l_chunk_offset);
            stream_Seek(p_demux->s, (i_cur_part * TIVO_PART_LENGTH) +
                l_chunk_offset);
            
            
            p_sys->i_stuff_cnt = 0;
            get_chunk_header(p_demux);
            
            if (p_sys->i_seq_rec < 0 || p_sys->i_seq_rec > p_sys->i_num_recs) {
                msg_Err(p_demux, "no SEQ hdr in chunk; table had one.");
                
                stream_Seek(p_demux->s, (l_cur_pos / CHUNK_SIZE) * CHUNK_SIZE);
                p_sys->i_stuff_cnt = 0;
                get_chunk_header(p_demux);
                return VLC_EGENERIC;
            }
            l_seek_secs = p_sys->rec_hdrs[p_sys->i_seq_rec].l_ty_pts /
                1000000000;
            msg_Dbg(p_demux, "found SEQ hdr for timestamp %02ld:%02ld:%02ld",
                l_seek_secs / 3600,
                (l_seek_secs / 60) % 60, l_seek_secs % 60);
            if (p_sys->rec_hdrs[p_sys->i_seq_rec].l_ty_pts >= l_seek_time) {
                
                

                msg_Dbg(p_demux, "seek target found.");
                break;
            }
            msg_Dbg(p_demux, "timestamp too early. still scanning.");
        }
    }
    



    if (i == p_sys->i_bits_per_seq_entry)
        return ty_stream_seek_time(p_demux, l_fwd_stamp);

    


    i_skip_cnt = 0;
    for (i=0; i<p_sys->i_seq_rec; i++)
        i_skip_cnt += p_sys->rec_hdrs[i].l_rec_size;
    stream_Read(p_demux->s, NULL, i_skip_cnt);
    p_sys->i_cur_rec = p_sys->i_seq_rec;
    
    

    return VLC_SUCCESS;
}