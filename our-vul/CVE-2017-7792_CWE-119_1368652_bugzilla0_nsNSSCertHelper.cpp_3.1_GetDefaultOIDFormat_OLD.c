static nsresult
GetDefaultOIDFormat(SECItem* oid, nsAString& outString, char separator)
{
  char buf[300];
  unsigned int len = 0;
  int written, invalidCount = 0;

  unsigned int i;
  unsigned long val = 0;
  bool invalid = false;
  bool first = true;

  val = 0;
  for (i = 0; i < oid->len; ++i) {
    
    
    
    
    
    
    unsigned long j;

    j = oid->data[i];
    val = (val << 7) | (j & 0x7f);
    if (j & 0x80) {
      
      
      
      
      
      
      
      if (val == 0 || (val >= (1 << (32 - 7))) || (i == oid->len - 1)) {
        invalid = true;
      }

      if (i < oid->len - 1)
        continue;
    }

    if (!invalid) {
      if (first) {
        unsigned long one = std::min(val / 40, 2UL); 
        unsigned long two = val - (one * 40);

        written = snprintf(
          &buf[len], sizeof(buf) - len, "%lu%c%lu", one, separator, two);
      } else {
        written =
          snprintf(&buf[len], sizeof(buf) - len, "%c%lu", separator, val);
      }
    } else {
      nsAutoString unknownText;
      GetPIPNSSBundleString("CertUnknown", unknownText);
      if (first) {
        written = snprintf(&buf[len],
                           sizeof(buf) - len,
                           "%s",
                           NS_ConvertUTF16toUTF8(unknownText).get());
      } else {
        written = snprintf(&buf[len],
                           sizeof(buf) - len,
                           "%c%s",
                           separator,
                           NS_ConvertUTF16toUTF8(unknownText).get());
      }

      if (++invalidCount > 3) {
        
        
        break;
      }
    }

    if (written < 0)
      return NS_ERROR_FAILURE;

    len += written;
    MOZ_ASSERT(len < sizeof(buf), "OID data too big to display in 300 chars.");
    val = 0;
    invalid = false;
    first = false;
  }

  CopyASCIItoUTF16(buf, outString);
  return NS_OK;
}