static fragment_head *
fragment_add_seq_common(reassembly_table *table, tvbuff_t *tvb,
			const int offset, const packet_info *pinfo,
			const guint32 id, const void *data,
			guint32 frag_number, const guint32 frag_data_len,
			const gboolean more_frags, const guint32 flags,
			gpointer *orig_keyp)
{
	fragment_head *fd_head;
	gpointer orig_key;

	fd_head = lookup_fd_head(table, pinfo, id, data, &orig_key);

	
	if (pinfo->fd->flags.visited) {
		if (fd_head != NULL && fd_head->flags & FD_DEFRAGMENTED) {
			if (orig_keyp != NULL)
				*orig_keyp = orig_key;
			return fd_head;
		} else {
			return NULL;
		}
	}

	if (fd_head==NULL){
		


		fd_head= new_head(FD_BLOCKSEQUENCE);

		if((flags & (REASSEMBLE_FLAGS_NO_FRAG_NUMBER|REASSEMBLE_FLAGS_802_11_HACK))
		   && !more_frags) {
			













			if (orig_keyp != NULL)
				*orig_keyp = NULL;
			fd_head->reassembled_in=pinfo->num;
			fd_head->reas_in_layer_num = pinfo->curr_layer_num;
			return fd_head;
		}

		orig_key = insert_fd_head(table, fd_head, pinfo, id, data);
		if (orig_keyp != NULL)
			*orig_keyp = orig_key;

		



		if (flags & REASSEMBLE_FLAGS_NO_FRAG_NUMBER)
			frag_number = 0;
	} else {
		if (orig_keyp != NULL)
			*orig_keyp = orig_key;

		if (flags & REASSEMBLE_FLAGS_NO_FRAG_NUMBER) {
			fragment_item *fd;
			




			for (fd = fd_head; fd != NULL; fd = fd->next) {
				if (fd->next == NULL)
					frag_number = fd->offset + 1;
			}
		}
	}

	













	if ((flags & REASSEMBLE_FLAGS_CHECK_DATA_PRESENT) &&
		!tvb_bytes_exist(tvb, offset, frag_data_len)) {
		fd_head -> flags |= FD_DATA_NOT_PRESENT;
		if (frag_number == 0) {
			return fd_head;
		}
		else {
			if (!more_frags) {
				




				fragment_unhash(table, *orig_keyp);
				free_all_fragments(NULL, fd_head, NULL);
			}
			return NULL;
		}
	}

	if (fragment_add_seq_work(fd_head, tvb, offset, pinfo,
				  frag_number, frag_data_len, more_frags)) {
		


		return fd_head;
	} else {
		


		return NULL;
	}
}