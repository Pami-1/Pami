fragment_head *
fragment_end_seq_next(reassembly_table *table, const packet_info *pinfo,
		      const guint32 id, const void *data)
{
	reassembled_key reass_key;
	reassembled_key *new_key;
	fragment_head *fd_head;
	gpointer orig_key;

	



	if (pinfo->fd->flags.visited) {
		reass_key.frame = pinfo->num;
		reass_key.id = id;
		return (fragment_head *)g_hash_table_lookup(table->reassembled_table, &reass_key);
	}

	fd_head = lookup_fd_head(table, pinfo, id, data, &orig_key);

	if (fd_head) {
		if (fd_head->flags & FD_DATA_NOT_PRESENT) {
			
			return NULL;
		}

		fd_head->datalen = fd_head->offset;
		fd_head->flags |= FD_DATALEN_SET;

		fragment_defragment_and_free (fd_head, pinfo);

		



		fragment_unhash(table, orig_key);

		


		fragment_reassembled(table, fd_head, pinfo, id);
		if (fd_head->next != NULL) {
			new_key = g_slice_new(reassembled_key);
			new_key->frame = pinfo->num;
			new_key->id = id;
			g_hash_table_insert(table->reassembled_table, new_key, fd_head);
		}

		return fd_head;
	} else {
		


		return NULL;
	}
}