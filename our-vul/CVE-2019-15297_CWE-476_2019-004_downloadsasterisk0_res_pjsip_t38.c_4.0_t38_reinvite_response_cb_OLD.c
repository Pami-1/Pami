static int t38_reinvite_response_cb(struct ast_sip_session *session, pjsip_rx_data *rdata)
{
	struct pjsip_status_line status = rdata->msg_info.msg->line.status;
	struct t38_state *state;
	struct ast_sip_session_media *session_media = NULL;

	if (status.code / 100 <= 1) {
		
		return 0;
	}

	if (session->t38state != T38_LOCAL_REINVITE) {
		
		ast_debug(3, "Received %d response to T.38 re-invite on '%s' but already had a final response (T.38 state:%d)\n",
			status.code,
			session->channel ? ast_channel_name(session->channel) : "unknown channel",
			session->t38state);
		return 0;
	}

	state = t38_state_get_or_alloc(session);
	if (!session->channel || !state) {
		ast_log(LOG_WARNING, "Received %d response to T.38 re-invite on '%s' but state unavailable\n",
			status.code,
			session->channel ? ast_channel_name(session->channel) : "unknown channel");
		return 0;
	}

	if (status.code / 100 == 2) {
		
		int index;

		session_media = session->active_media_state->default_session[AST_MEDIA_TYPE_IMAGE];
		t38_change_state(session, session_media, state, T38_ENABLED);

		


		for (index = 0; index < AST_VECTOR_SIZE(&state->media_state->sessions); ++index) {
			struct ast_sip_session_media *session_media = AST_VECTOR_GET(&state->media_state->sessions, index);

			if (session_media && session_media->handler && session_media->handler->stream_stop) {
				session_media->handler->stream_stop(session_media);
			}
		}
	} else {
		session_media = session->pending_media_state->default_session[AST_MEDIA_TYPE_IMAGE];
		t38_change_state(session, session_media, state, T38_REJECTED);

		
		ast_sip_session_media_state_free(state->media_state);
		state->media_state = NULL;
		ast_sip_session_media_state_reset(session->pending_media_state);
	}

	return 0;
}