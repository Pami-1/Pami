static int get_chunk_header(demux_t *p_demux)
{
    int i_readSize, i_num_recs;
    uint8_t *p_hdr_buf;
    const uint8_t *p_peek;
    demux_sys_t *p_sys = p_demux->p_sys;
    int i_payload_size;             

    msg_Dbg(p_demux, "parsing ty chunk #%d", p_sys->i_cur_chunk );

    
    if (p_sys->i_stuff_cnt > 0) {
        stream_Read( p_demux->s, NULL, p_sys->i_stuff_cnt);
        p_sys->i_stuff_cnt = 0;
    }

    
    i_readSize = stream_Peek( p_demux->s, &p_peek, 4 );
    p_sys->i_cur_chunk++;

    if ( (i_readSize < 4) || ( U32_AT(&p_peek[ 0 ] ) == 0 ))
    {
        
        p_sys->eof = 1;
        return 0;
    }

    
    if( U32_AT( &p_peek[ 0 ] ) == TIVO_PES_FILEID )
    {
        
        parse_master(p_demux);
        return get_chunk_header(p_demux);
    }

    
    if (p_peek[3] & 0x80)
    {
        
        p_sys->i_num_recs = i_num_recs = (p_peek[1] << 8) + p_peek[0];
        p_sys->i_seq_rec = (p_peek[3] << 8) + p_peek[2];
        if (p_sys->i_seq_rec != 0xffff)
        {
            p_sys->i_seq_rec &= ~0x8000;
        }
    }
    else
    {
        
        p_sys->i_num_recs = i_num_recs = p_peek[0];
        p_sys->i_seq_rec = p_peek[1];
    }
    p_sys->i_cur_rec = 0;
    p_sys->b_first_chunk = false;

    

    free(p_sys->rec_hdrs);

    
    stream_Read( p_demux->s, NULL, 4 );

    
    p_hdr_buf = xmalloc(i_num_recs * 16);
    if (stream_Read(p_demux->s, p_hdr_buf, i_num_recs * 16) < i_num_recs * 16) {
        free( p_hdr_buf );
        p_sys->eof = true;
        return 0;
    }
    
    p_sys->rec_hdrs = parse_chunk_headers(p_hdr_buf, i_num_recs,
            &i_payload_size);
    free(p_hdr_buf);

    p_sys->i_stuff_cnt = CHUNK_SIZE - 4 -
        (p_sys->i_num_recs * 16) - i_payload_size;
    if (p_sys->i_stuff_cnt > 0)
        msg_Dbg( p_demux, "chunk has %d stuff bytes at end",
                 p_sys->i_stuff_cnt );
    return 1;
}