static gboolean
pcapng_read_if_descr_block(wtap *wth, FILE_T fh, pcapng_block_header_t *bh,
                           pcapng_t *pn, wtapng_block_t *wblock, int *err,
                           gchar **err_info)
{
    guint64 time_units_per_second = 1000000; 
    int     tsprecision = WTAP_TSPREC_USEC;
    int     bytes_read;
    guint to_read, opt_cont_buf_len;
    pcapng_interface_description_block_t idb;
    pcapng_option_header_t oh;
    guint8 *option_content = NULL; 

    


    if (bh->block_total_length < MIN_IDB_SIZE) {
        


        *err = WTAP_ERR_BAD_FILE;
        *err_info = g_strdup_printf("pcapng_read_if_descr_block: total block length %u of an IDB is less than the minimum IDB size %u",
                                    bh->block_total_length, MIN_IDB_SIZE);
        return FALSE;
    }

    







    if (bh->block_total_length > MAX_BLOCK_SIZE) {
        *err = WTAP_ERR_BAD_FILE;
        *err_info = g_strdup_printf("pcapng: total block length %u is too large (> %u)",
                                    bh->block_total_length, MAX_BLOCK_SIZE);
        return FALSE;
    }

    
    if (!wtap_read_bytes(fh, &idb, sizeof idb, err, err_info)) {
        pcapng_debug0("pcapng_read_if_descr_block: failed to read IDB");
        return FALSE;
    }

    
    if (pn->byte_swapped) {
        wblock->data.if_descr.link_type = GUINT16_SWAP_LE_BE(idb.linktype);
        wblock->data.if_descr.snap_len  = GUINT32_SWAP_LE_BE(idb.snaplen);
    } else {
        wblock->data.if_descr.link_type = idb.linktype;
        wblock->data.if_descr.snap_len  = idb.snaplen;
    }

    wblock->data.if_descr.wtap_encap = wtap_pcap_encap_to_wtap_encap(wblock->data.if_descr.link_type);
    wblock->data.if_descr.time_units_per_second = time_units_per_second;
    wblock->data.if_descr.tsprecision = tsprecision;

    pcapng_debug3("pcapng_read_if_descr_block: IDB link_type %u (%s), snap %u",
                  wblock->data.if_descr.link_type,
                  wtap_encap_string(wblock->data.if_descr.wtap_encap),
                  wblock->data.if_descr.snap_len);

    if (wblock->data.if_descr.snap_len > WTAP_MAX_PACKET_SIZE) {
        



        pcapng_debug1("pcapng_read_if_descr_block: snapshot length %u unrealistic.",
                      wblock->data.if_descr.snap_len);
        
    }

    
    wblock->data.if_descr.opt_comment = NULL;
    wblock->data.if_descr.if_name = NULL;
    wblock->data.if_descr.if_description = NULL;
    
    
    
    
    wblock->data.if_descr.if_speed = 0;                     
    wblock->data.if_descr.if_tsresol = 6;                   
    wblock->data.if_descr.if_filter_str = NULL;
    wblock->data.if_descr.bpf_filter_len = 0;
    wblock->data.if_descr.if_filter_bpf_bytes = NULL;
    wblock->data.if_descr.if_os = NULL;
    wblock->data.if_descr.if_fcslen = -1;                   
    


    
    to_read = bh->block_total_length - MIN_IDB_SIZE;

    
    opt_cont_buf_len = to_read;
    option_content = (guint8 *)g_try_malloc(opt_cont_buf_len);
    if (opt_cont_buf_len != 0 && option_content == NULL) {
        *err = ENOMEM;  
        return FALSE;
    }

    while (to_read != 0) {
        
        bytes_read = pcapng_read_option(fh, pn, &oh, option_content, opt_cont_buf_len, to_read, err, err_info);
        if (bytes_read <= 0) {
            pcapng_debug0("pcapng_read_if_descr_block: failed to read option");
            return FALSE;
        }
        to_read -= bytes_read;

        
        switch (oh.option_code) {
            case(OPT_EOFOPT): 
                if (to_read != 0) {
                    pcapng_debug1("pcapng_read_if_descr_block: %u bytes after opt_endofopt", to_read);
                }
                
                to_read = 0;
                break;
            case(OPT_COMMENT): 
                if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {
                    wblock->data.if_descr.opt_comment = g_strndup((char *)option_content, oh.option_length);
                    pcapng_debug1("pcapng_read_if_descr_block: opt_comment %s", wblock->data.if_descr.opt_comment);
                } else {
                    pcapng_debug1("pcapng_read_if_descr_block: opt_comment length %u seems strange", oh.option_length);
                }
                break;
            case(OPT_IDB_NAME): 
                if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {
                    wblock->data.if_descr.if_name = g_strndup((char *)option_content, oh.option_length);
                    pcapng_debug1("pcapng_read_if_descr_block: if_name %s", wblock->data.if_descr.if_name);
                } else {
                    pcapng_debug1("pcapng_read_if_descr_block: if_name length %u seems strange", oh.option_length);
                }
                break;
            case(OPT_IDB_DESCR): 
                if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {
                    wblock->data.if_descr.if_description = g_strndup((char *)option_content, oh.option_length);
                    pcapng_debug1("pcapng_read_if_descr_block: if_description %s", wblock->data.if_descr.if_description);
                } else {
                    pcapng_debug1("pcapng_read_if_descr_block: if_description length %u seems strange", oh.option_length);
                }
                break;
            case(OPT_IDB_SPEED): 
                if (oh.option_length == 8) {
                    



                    memcpy(&wblock->data.if_descr.if_speed, option_content, sizeof(guint64));
                    if (pn->byte_swapped)
                        wblock->data.if_descr.if_speed = GUINT64_SWAP_LE_BE(wblock->data.if_descr.if_speed);
                    pcapng_debug1("pcapng_read_if_descr_block: if_speed %" G_GINT64_MODIFIER "u (bps)", wblock->data.if_descr.if_speed);
                } else {
                    pcapng_debug1("pcapng_read_if_descr_block: if_speed length %u not 8 as expected", oh.option_length);
                }
                break;
            case(OPT_IDB_TSRESOL): 
                if (oh.option_length == 1) {
                    guint64 base;
                    guint64 result;
                    guint8 i, exponent, if_tsresol;

                    if_tsresol = option_content[0];
                    if (if_tsresol & 0x80) {
                        base = 2;
                    } else {
                        base = 10;
                    }
                    exponent = (guint8)(if_tsresol & 0x7f);
                    if (((base == 2) && (exponent < 64)) || ((base == 10) && (exponent < 20))) {
                        result = 1;
                        for (i = 0; i < exponent; i++) {
                            result *= base;
                        }
                        time_units_per_second = result;
                    } else {
                        time_units_per_second = G_MAXUINT64;
                    }
                    if (time_units_per_second > (((guint64)1) << 32)) {
                        pcapng_debug0("pcapng_open: time conversion might be inaccurate");
                    }
                    wblock->data.if_descr.time_units_per_second = time_units_per_second;
                    wblock->data.if_descr.if_tsresol = if_tsresol;
                    if (time_units_per_second >= 1000000000)
                        tsprecision = WTAP_TSPREC_NSEC;
                    else if (time_units_per_second >= 1000000)
                        tsprecision = WTAP_TSPREC_USEC;
                    else if (time_units_per_second >= 1000)
                        tsprecision = WTAP_TSPREC_MSEC;
                    else if (time_units_per_second >= 100)
                        tsprecision = WTAP_TSPREC_CSEC;
                    else if (time_units_per_second >= 10)
                        tsprecision = WTAP_TSPREC_DSEC;
                    else
                        tsprecision = WTAP_TSPREC_SEC;
                    wblock->data.if_descr.tsprecision = tsprecision;
                    pcapng_debug3("pcapng_read_if_descr_block: if_tsresol %u, units/s %" G_GINT64_MODIFIER "u, tsprecision %d", wblock->data.if_descr.if_tsresol, wblock->data.if_descr.time_units_per_second, tsprecision);
                } else {
                    pcapng_debug1("pcapng_read_if_descr_block: if_tsresol length %u not 1 as expected", oh.option_length);
                }
                break;
                


            case(OPT_IDB_FILTER): 
                if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {
                    


                    if (option_content[0] == 0) {
                        wblock->data.if_descr.if_filter_str = g_strndup((char *)option_content+1, oh.option_length-1);
                        pcapng_debug2("pcapng_read_if_descr_block: if_filter_str %s oh.option_length %u", wblock->data.if_descr.if_filter_str, oh.option_length);
                    } else if (option_content[0] == 1) {
                        wblock->data.if_descr.bpf_filter_len = oh.option_length-1;
                        wblock->data.if_descr.if_filter_bpf_bytes = (gchar *)g_malloc(oh.option_length-1);
                        memcpy(&wblock->data.if_descr.if_filter_bpf_bytes, (char *)option_content+1, oh.option_length-1);
                    }
                } else {
                    pcapng_debug1("pcapng_read_if_descr_block: if_filter length %u seems strange", oh.option_length);
                }
                break;
            case(OPT_IDB_OS): 
                




                if (oh.option_length > 0 && oh.option_length < opt_cont_buf_len) {
                    wblock->data.if_descr.if_os = g_strndup((char *)option_content, oh.option_length);
                    pcapng_debug1("pcapng_read_if_descr_block: if_os %s", wblock->data.if_descr.if_os);
                } else {
                    pcapng_debug1("pcapng_read_if_descr_block: if_os length %u seems strange", oh.option_length);
                }
                break;
            case(OPT_IDB_FCSLEN): 
                if (oh.option_length == 1) {
                    wblock->data.if_descr.if_fcslen = option_content[0];
                    pn->if_fcslen = wblock->data.if_descr.if_fcslen;
                    pcapng_debug1("pcapng_read_if_descr_block: if_fcslen %u", wblock->data.if_descr.if_fcslen);
                    
                } else {
                    pcapng_debug1("pcapng_read_if_descr_block: if_fcslen length %u not 1 as expected", oh.option_length);
                }
                break;

            
            case(OPT_IDB_IP4ADDR):
                





            case(OPT_IDB_IP6ADDR):
                








            case(OPT_IDB_MACADDR):
                


            case(OPT_IDB_EUIADDR):
                



            case(OPT_IDB_TZONE):
                



            case(OPT_IDB_TSOFFSET):
                










            default:
                pcapng_debug2("pcapng_read_if_descr_block: unknown option %u - ignoring %u bytes",
                              oh.option_code, oh.option_length);
        }
    }

    g_free(option_content);

    









    if (wth->file_encap == WTAP_ENCAP_UNKNOWN) {
        wth->file_encap = wblock->data.if_descr.wtap_encap;
    } else {
        if (wth->file_encap != wblock->data.if_descr.wtap_encap) {
            wth->file_encap = WTAP_ENCAP_PER_PACKET;
        }
    }

    


    if (wth->file_tsprec == WTAP_TSPREC_UNKNOWN) {
        wth->file_tsprec = wblock->data.if_descr.tsprecision;
    } else {
        if (wth->file_tsprec != wblock->data.if_descr.tsprecision) {
            wth->file_tsprec = WTAP_TSPREC_PER_PACKET;
        }
    }

    return TRUE;
}