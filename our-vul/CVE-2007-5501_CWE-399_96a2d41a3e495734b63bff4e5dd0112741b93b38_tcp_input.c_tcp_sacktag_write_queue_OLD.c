static int
tcp_sacktag_write_queue(struct sock *sk, struct sk_buff *ack_skb, u32 prior_snd_una)
{
	const struct inet_connection_sock *icsk = inet_csk(sk);
	struct tcp_sock *tp = tcp_sk(sk);
	unsigned char *ptr = (skb_transport_header(ack_skb) +
			      TCP_SKB_CB(ack_skb)->sacked);
	struct tcp_sack_block_wire *sp = (struct tcp_sack_block_wire *)(ptr+2);
	struct sk_buff *cached_skb;
	int num_sacks = (ptr[1] - TCPOLEN_SACK_BASE)>>3;
	int reord = tp->packets_out;
	int prior_fackets;
	u32 highest_sack_end_seq = tp->lost_retrans_low;
	int flag = 0;
	int found_dup_sack = 0;
	int cached_fack_count;
	int i;
	int first_sack_index;
	int force_one_sack;

	if (!tp->sacked_out) {
		if (WARN_ON(tp->fackets_out))
			tp->fackets_out = 0;
		tp->highest_sack = tp->snd_una;
	}
	prior_fackets = tp->fackets_out;

	found_dup_sack = tcp_check_dsack(tp, ack_skb, sp,
					 num_sacks, prior_snd_una);
	if (found_dup_sack)
		flag |= FLAG_DSACKING_ACK;

	



	if (before(TCP_SKB_CB(ack_skb)->ack_seq, prior_snd_una - tp->max_window))
		return 0;

	



	force_one_sack = 1;
	for (i = 0; i < num_sacks; i++) {
		__be32 start_seq = sp[i].start_seq;
		__be32 end_seq = sp[i].end_seq;

		if (i == 0) {
			if (tp->recv_sack_cache[i].start_seq != start_seq)
				force_one_sack = 0;
		} else {
			if ((tp->recv_sack_cache[i].start_seq != start_seq) ||
			    (tp->recv_sack_cache[i].end_seq != end_seq))
				force_one_sack = 0;
		}
		tp->recv_sack_cache[i].start_seq = start_seq;
		tp->recv_sack_cache[i].end_seq = end_seq;
	}
	
	for (; i < ARRAY_SIZE(tp->recv_sack_cache); i++) {
		tp->recv_sack_cache[i].start_seq = 0;
		tp->recv_sack_cache[i].end_seq = 0;
	}

	first_sack_index = 0;
	if (force_one_sack)
		num_sacks = 1;
	else {
		int j;
		tp->fastpath_skb_hint = NULL;

		
		for (i = num_sacks-1; i > 0; i--) {
			for (j = 0; j < i; j++){
				if (after(ntohl(sp[j].start_seq),
					  ntohl(sp[j+1].start_seq))){
					struct tcp_sack_block_wire tmp;

					tmp = sp[j];
					sp[j] = sp[j+1];
					sp[j+1] = tmp;

					
					if (j == first_sack_index)
						first_sack_index = j+1;
				}

			}
		}
	}

	
	cached_skb = tp->fastpath_skb_hint;
	cached_fack_count = tp->fastpath_cnt_hint;
	if (!cached_skb) {
		cached_skb = tcp_write_queue_head(sk);
		cached_fack_count = 0;
	}

	for (i = 0; i < num_sacks; i++) {
		struct sk_buff *skb;
		__u32 start_seq = ntohl(sp->start_seq);
		__u32 end_seq = ntohl(sp->end_seq);
		int fack_count;
		int dup_sack = (found_dup_sack && (i == first_sack_index));
		int next_dup = (found_dup_sack && (i+1 == first_sack_index));

		sp++;

		if (!tcp_is_sackblock_valid(tp, dup_sack, start_seq, end_seq)) {
			if (dup_sack) {
				if (!tp->undo_marker)
					NET_INC_STATS_BH(LINUX_MIB_TCPDSACKIGNOREDNOUNDO);
				else
					NET_INC_STATS_BH(LINUX_MIB_TCPDSACKIGNOREDOLD);
			} else {
				
				if ((TCP_SKB_CB(ack_skb)->ack_seq != tp->snd_una) &&
				    !after(end_seq, tp->snd_una))
					continue;
				NET_INC_STATS_BH(LINUX_MIB_TCPSACKDISCARD);
			}
			continue;
		}

		skb = cached_skb;
		fack_count = cached_fack_count;

		
		if (after(end_seq, tp->high_seq))
			flag |= FLAG_DATA_LOST;

		tcp_for_write_queue_from(skb, sk) {
			int in_sack = 0;
			u8 sacked;

			if (skb == tcp_send_head(sk))
				break;

			cached_skb = skb;
			cached_fack_count = fack_count;
			if (i == first_sack_index) {
				tp->fastpath_skb_hint = skb;
				tp->fastpath_cnt_hint = fack_count;
			}

			


			if (!before(TCP_SKB_CB(skb)->seq, end_seq))
				break;

			dup_sack = (found_dup_sack && (i == first_sack_index));

			
			if (next_dup) {
				u32 dup_start = ntohl(sp->start_seq);
				u32 dup_end = ntohl(sp->end_seq);

				if (before(TCP_SKB_CB(skb)->seq, dup_end)) {
					in_sack = tcp_match_skb_to_sack(sk, skb, dup_start, dup_end);
					if (in_sack > 0)
						dup_sack = 1;
				}
			}

			
			if (in_sack <= 0)
				in_sack = tcp_match_skb_to_sack(sk, skb, start_seq, end_seq);
			if (unlikely(in_sack < 0))
				break;

			sacked = TCP_SKB_CB(skb)->sacked;

			
			if ((dup_sack && in_sack) &&
			    (sacked & TCPCB_RETRANS) &&
			    after(TCP_SKB_CB(skb)->end_seq, tp->undo_marker))
				tp->undo_retrans--;

			
			if (!after(TCP_SKB_CB(skb)->end_seq, tp->snd_una)) {
				if (sacked&TCPCB_RETRANS) {
					if ((dup_sack && in_sack) &&
					    (sacked&TCPCB_SACKED_ACKED))
						reord = min(fack_count, reord);
				}

				
				fack_count += tcp_skb_pcount(skb);
				continue;
			}

			if (!in_sack) {
				fack_count += tcp_skb_pcount(skb);
				continue;
			}

			if (!(sacked&TCPCB_SACKED_ACKED)) {
				if (sacked & TCPCB_SACKED_RETRANS) {
					



					if (sacked & TCPCB_LOST) {
						TCP_SKB_CB(skb)->sacked &= ~(TCPCB_LOST|TCPCB_SACKED_RETRANS);
						tp->lost_out -= tcp_skb_pcount(skb);
						tp->retrans_out -= tcp_skb_pcount(skb);

						
						tp->retransmit_skb_hint = NULL;
					}
				} else {
					if (!(sacked & TCPCB_RETRANS)) {
						


						if (fack_count < prior_fackets)
							reord = min(fack_count, reord);

						
						if (!after(TCP_SKB_CB(skb)->end_seq, tp->frto_highmark))
							flag |= FLAG_ONLY_ORIG_SACKED;
					}

					if (sacked & TCPCB_LOST) {
						TCP_SKB_CB(skb)->sacked &= ~TCPCB_LOST;
						tp->lost_out -= tcp_skb_pcount(skb);

						
						tp->retransmit_skb_hint = NULL;
					}
				}

				TCP_SKB_CB(skb)->sacked |= TCPCB_SACKED_ACKED;
				flag |= FLAG_DATA_SACKED;
				tp->sacked_out += tcp_skb_pcount(skb);

				fack_count += tcp_skb_pcount(skb);
				if (fack_count > tp->fackets_out)
					tp->fackets_out = fack_count;

				if (after(TCP_SKB_CB(skb)->seq, tp->highest_sack)) {
					tp->highest_sack = TCP_SKB_CB(skb)->seq;
					highest_sack_end_seq = TCP_SKB_CB(skb)->end_seq;
				}
			} else {
				if (dup_sack && (sacked&TCPCB_RETRANS))
					reord = min(fack_count, reord);

				fack_count += tcp_skb_pcount(skb);
			}

			




			if (dup_sack &&
			    (TCP_SKB_CB(skb)->sacked&TCPCB_SACKED_RETRANS)) {
				TCP_SKB_CB(skb)->sacked &= ~TCPCB_SACKED_RETRANS;
				tp->retrans_out -= tcp_skb_pcount(skb);
				tp->retransmit_skb_hint = NULL;
			}
		}

		


		if (after(end_seq, tp->frto_highmark))
			flag &= ~FLAG_ONLY_ORIG_SACKED;
	}

	if (tp->retrans_out &&
	    after(highest_sack_end_seq, tp->lost_retrans_low) &&
	    icsk->icsk_ca_state == TCP_CA_Recovery)
		flag |= tcp_mark_lost_retrans(sk, highest_sack_end_seq);

	tcp_verify_left_out(tp);

	if ((reord < tp->fackets_out) && icsk->icsk_ca_state != TCP_CA_Loss &&
	    (!tp->frto_highmark || after(tp->snd_una, tp->frto_highmark)))
		tcp_update_reordering(sk, tp->fackets_out - reord, 0);

#if FASTRETRANS_DEBUG > 0
	BUG_TRAP((int)tp->sacked_out >= 0);
	BUG_TRAP((int)tp->lost_out >= 0);
	BUG_TRAP((int)tp->retrans_out >= 0);
	BUG_TRAP((int)tcp_packets_in_flight(tp) >= 0);
#endif
	return flag;
}