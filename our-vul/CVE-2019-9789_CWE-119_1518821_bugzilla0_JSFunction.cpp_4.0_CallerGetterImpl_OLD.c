bool CallerGetterImpl(JSContext* cx, const CallArgs& args) {
  MOZ_ASSERT(IsFunction(args.thisv()));

  
  
  
  
  RootedFunction fun(cx, &args.thisv().toObject().as<JSFunction>());
  if (!CallerRestrictions(cx, fun)) {
    return false;
  }

  
  NonBuiltinScriptFrameIter iter(cx);
  if (!AdvanceToActiveCallLinear(cx, iter, fun)) {
    args.rval().setNull();
    return true;
  }

  ++iter;
  while (!iter.done() && iter.isEvalFrame()) {
    ++iter;
  }

  if (iter.done() || !iter.isFunctionFrame()) {
    args.rval().setNull();
    return true;
  }

  RootedObject caller(cx, iter.callee(cx));
  if (caller->is<JSFunction>() && caller->as<JSFunction>().isAsync()) {
    caller = GetWrappedAsyncFunction(&caller->as<JSFunction>());
  }
  if (!cx->compartment()->wrap(cx, &caller)) {
    return false;
  }

  
  
  
  {
    JSObject* callerObj = CheckedUnwrap(caller);
    if (!callerObj) {
      args.rval().setNull();
      return true;
    }

    JSFunction* callerFun = &callerObj->as<JSFunction>();
    if (IsWrappedAsyncFunction(callerFun)) {
      callerFun = GetUnwrappedAsyncFunction(callerFun);
    } else if (IsWrappedAsyncGenerator(callerFun)) {
      callerFun = GetUnwrappedAsyncGenerator(callerFun);
    }
    MOZ_ASSERT(!callerFun->isBuiltin(),
               "non-builtin iterator returned a builtin?");

    if (callerFun->strict()) {
      JS_ReportErrorNumberASCII(cx, GetErrorMessage, nullptr,
                                JSMSG_CALLER_IS_STRICT);
      return false;
    }
  }

  args.rval().setObject(*caller);
  return true;
}