static int
call_dissector_work(dissector_handle_t handle, tvbuff_t *tvb, packet_info *pinfo_arg,
		    proto_tree *tree, gboolean add_proto_name, void *data)
{
 	packet_info *pinfo = pinfo_arg;
	const char  *saved_proto;
	guint16      saved_can_desegment;
	int          len;
	guint        saved_layers_len = 0;

	if (handle->protocol != NULL &&
	    !proto_is_protocol_enabled(handle->protocol)) {
		


		return 0;
	}

	saved_proto = pinfo->current_proto;
	saved_can_desegment = pinfo->can_desegment;
	saved_layers_len = wmem_list_count(pinfo->layers);

	











	pinfo->saved_can_desegment = saved_can_desegment;
	pinfo->can_desegment = saved_can_desegment-(saved_can_desegment>0);
	if ((handle->protocol != NULL) && (!proto_is_pino(handle->protocol))) {
		pinfo->current_proto =
			proto_get_protocol_short_name(handle->protocol);

		



		if (add_proto_name) {
			pinfo->curr_layer_num++;
			wmem_list_append(pinfo->layers, GINT_TO_POINTER(proto_get_id(handle->protocol)));
		}
	}

	if (pinfo->flags.in_error_pkt) {
		len = call_dissector_work_error(handle, tvb, pinfo, tree, data);
	} else {
		


		len = call_dissector_through_handle(handle, tvb, pinfo, tree, data);
	}
	if (len == 0) {
		




		while (wmem_list_count(pinfo->layers) > saved_layers_len) {
			wmem_list_remove_frame(pinfo->layers, wmem_list_tail(pinfo->layers));
		}
 	}
 	pinfo->current_proto = saved_proto;
 	pinfo->can_desegment = saved_can_desegment;
	return len;
}