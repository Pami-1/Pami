wtap_open_return_val netmon_open(wtap *wth, int *err, gchar **err_info)
{
	char magic[MAGIC_SIZE];
	struct netmon_hdr hdr;
	int file_type;
	struct tm tm;
	guint32 frame_table_offset;
	guint32 frame_table_length;
	guint32 frame_table_size;
	guint32 *frame_table;
	guint32 comment_table_offset, process_info_table_offset;
	guint32 comment_table_size, process_info_table_count;
	GHashTable *comment_table, *process_info_table;
	struct netmonrec_comment* comment_rec;
	gint64 file_size = wtap_file_size(wth, err);
#ifdef WORDS_BIGENDIAN
	unsigned int i;
#endif
	netmon_t *netmon;

	

	if (!wtap_read_bytes(wth->fh, magic, MAGIC_SIZE, err, err_info)) {
		if (*err != WTAP_ERR_SHORT_READ)
			return WTAP_OPEN_ERROR;
		return WTAP_OPEN_NOT_MINE;
	}

	if (memcmp(magic, netmon_1_x_magic, MAGIC_SIZE) != 0 &&
	    memcmp(magic, netmon_2_x_magic, MAGIC_SIZE) != 0) {
		return WTAP_OPEN_NOT_MINE;
	}

	
	if (!wtap_read_bytes(wth->fh, &hdr, sizeof hdr, err, err_info))
		return WTAP_OPEN_ERROR;

	switch (hdr.ver_major) {

	case 1:
		file_type = WTAP_FILE_TYPE_SUBTYPE_NETMON_1_x;
		break;

	case 2:
		file_type = WTAP_FILE_TYPE_SUBTYPE_NETMON_2_x;
		break;

	default:
		*err = WTAP_ERR_UNSUPPORTED;
		*err_info = g_strdup_printf("netmon: major version %u unsupported", hdr.ver_major);
		return WTAP_OPEN_ERROR;
	}

	hdr.network = pletoh16(&hdr.network);
	if (hdr.network >= NUM_NETMON_ENCAPS
	    || netmon_encap[hdr.network] == WTAP_ENCAP_UNKNOWN) {
		*err = WTAP_ERR_UNSUPPORTED;
		*err_info = g_strdup_printf("netmon: network type %u unknown or unsupported",
		    hdr.network);
		return WTAP_OPEN_ERROR;
	}

	
	wth->file_type_subtype = file_type;
	netmon = (netmon_t *)g_malloc0(sizeof(netmon_t));
	wth->priv = (void *)netmon;
	wth->subtype_read = netmon_read;
	wth->subtype_seek_read = netmon_seek_read;
	wth->subtype_close = netmon_close;

	

	if((hdr.ver_major == 2 && hdr.ver_minor >= 1) || hdr.ver_major > 2)
		wth->file_encap = WTAP_ENCAP_PER_PACKET;
	else
		wth->file_encap = netmon_encap[hdr.network];

	wth->snapshot_length = 0;	
	



	tm.tm_year = pletoh16(&hdr.ts_year) - 1900;
	tm.tm_mon = pletoh16(&hdr.ts_month) - 1;
	tm.tm_mday = pletoh16(&hdr.ts_day);
	tm.tm_hour = pletoh16(&hdr.ts_hour);
	tm.tm_min = pletoh16(&hdr.ts_min);
	tm.tm_sec = pletoh16(&hdr.ts_sec);
	tm.tm_isdst = -1;
	netmon->start_secs = mktime(&tm);
	













	netmon->start_nsecs = pletoh16(&hdr.ts_msec)*1000000;

	netmon->version_major = hdr.ver_major;
	netmon->version_minor = hdr.ver_minor;

	


	frame_table_offset = pletoh32(&hdr.frametableoffset);

	






	if ((netmon->version_major == 2 && netmon->version_minor >= 2) ||
	    netmon->version_major > 2) {
		comment_table_offset = pletoh32(&hdr.commentdataoffset);
		comment_table_size = pletoh32(&hdr.commentdatalength);
		process_info_table_offset = pletoh32(&hdr.processinfooffset);
		process_info_table_count = pletoh32(&hdr.processinfocount);
	} else {
		comment_table_offset = 0;
		comment_table_size = 0;
		process_info_table_offset = 0;
		process_info_table_count = 0;
	}

	










	frame_table_length = pletoh32(&hdr.frametablelength);
	frame_table_size = frame_table_length / (guint32)sizeof (guint32);
	if ((frame_table_size * sizeof (guint32)) != frame_table_length) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup_printf("netmon: frame table length is %u, which is not a multiple of the size of an entry",
		    frame_table_length);
		return WTAP_OPEN_ERROR;
	}
	if (frame_table_size == 0) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup_printf("netmon: frame table length is %u, which means it's less than one entry in size",
		    frame_table_length);
		return WTAP_OPEN_ERROR;
	}
	












	if (frame_table_size > 512*1024*1024) {
		*err = WTAP_ERR_BAD_FILE;
		*err_info = g_strdup_printf("netmon: frame table length is %u, which is larger than we support",
		    frame_table_length);
		return WTAP_OPEN_ERROR;
	}
	if (file_seek(wth->fh, frame_table_offset, SEEK_SET, err) == -1) {
		return WTAP_OPEN_ERROR;
	}

	



	if (comment_table_size > 0) {
		





		if (comment_table_size > 512*1024*1024) {
			*err = WTAP_ERR_BAD_FILE;
			*err_info = g_strdup_printf("netmon: comment table size is %u, which is larger than we support",
				comment_table_size);
			return WTAP_OPEN_ERROR;
		}

		if (comment_table_size < 17) {
			*err = WTAP_ERR_BAD_FILE;
			*err_info = g_strdup_printf("netmon: comment table size is %u, which is too small to use",
				comment_table_size);
			return WTAP_OPEN_ERROR;
		}

		if (comment_table_offset > file_size) {
			*err = WTAP_ERR_BAD_FILE;
			*err_info = g_strdup_printf("netmon: comment table offset (%u) is larger than file",
				comment_table_offset);
			return WTAP_OPEN_ERROR;
		}
	}

	



	if ((process_info_table_offset > 0) && (process_info_table_count > 0)) {
		



		if (process_info_table_count > 512*1024) {
			*err = WTAP_ERR_BAD_FILE;
			*err_info = g_strdup_printf("netmon: process info table size is %u, which is larger than we support",
				process_info_table_count);
			return WTAP_OPEN_ERROR;
		}

		if (process_info_table_offset > file_size) {
			*err = WTAP_ERR_BAD_FILE;
			*err_info = g_strdup_printf("netmon: process info table offset (%u) is larger than file",
				process_info_table_offset);
			return WTAP_OPEN_ERROR;
		}
	}

	


	if (file_seek(wth->fh, frame_table_offset, SEEK_SET, err) == -1) {
		return WTAP_OPEN_ERROR;
	}

	




	frame_table = (guint32 *)g_try_malloc(frame_table_length);
	if (frame_table_length != 0 && frame_table == NULL) {
		*err = ENOMEM;	
		return WTAP_OPEN_ERROR;
	}
	if (!wtap_read_bytes(wth->fh, frame_table, frame_table_length,
	    err, err_info)) {
		g_free(frame_table);
		return WTAP_OPEN_ERROR;
	}
	netmon->frame_table_size = frame_table_size;
	netmon->frame_table = frame_table;

	if (comment_table_size > 0) {
		comment_table = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, netmonrec_comment_destroy);
		if (comment_table == NULL) {
				*err = ENOMEM;	
				return WTAP_OPEN_ERROR;
		}

		
		if (file_seek(wth->fh, comment_table_offset+comment_table_size, SEEK_SET, err) == -1) {
			g_hash_table_destroy(comment_table);
			return WTAP_OPEN_ERROR;
		}

		if (file_seek(wth->fh, comment_table_offset, SEEK_SET, err) == -1) {
			
			g_hash_table_destroy(comment_table);
			return WTAP_OPEN_ERROR;
		}

		while (comment_table_size > 16) {
			struct netmonrec_comment_header comment_header;
			guint32 desc_length;

			
			if (!wtap_read_bytes(wth->fh, &comment_header, 12, err, err_info)) {
				g_hash_table_destroy(comment_table);
				return WTAP_OPEN_ERROR;
			}
			comment_table_size -= 12;

			
			if (pletoh32(&comment_header.titleLength) == 0) {
				*err = WTAP_ERR_BAD_FILE;
				*err_info = g_strdup("netmon: comment title size can't be 0");
				g_hash_table_destroy(comment_table);
				return WTAP_OPEN_ERROR;
			}
			if (pletoh32(&comment_header.titleLength) > comment_table_size) {
				*err = WTAP_ERR_BAD_FILE;
				*err_info = g_strdup_printf("netmon: comment title size is %u, which is larger than the entire comment section (%d)",
						pletoh32(&comment_header.titleLength), comment_table_size);
				g_hash_table_destroy(comment_table);
				return WTAP_OPEN_ERROR;
			}

			comment_rec = g_new(struct netmonrec_comment, 1);
			comment_rec->numFramePerComment = pletoh32(&comment_header.numFramePerComment);
			comment_rec->frameOffset = pletoh32(&comment_header.frameOffset);
			comment_rec->titleLength = pletoh32(&comment_header.titleLength);
			comment_rec->title = (guint8*)g_malloc(comment_rec->titleLength);

			g_hash_table_insert(comment_table, GUINT_TO_POINTER(comment_rec->frameOffset), comment_rec);

			
			if (!wtap_read_bytes(wth->fh, comment_rec->title, comment_rec->titleLength, err, err_info)) {
				g_hash_table_destroy(comment_table);
				return WTAP_OPEN_ERROR;
			}
			comment_table_size -= comment_rec->titleLength;

			if (comment_table_size < 4) {
				*err = WTAP_ERR_BAD_FILE;
				*err_info = g_strdup("netmon: corrupt comment section");
				g_hash_table_destroy(comment_table);
				return WTAP_OPEN_ERROR;
			}

			if (!wtap_read_bytes(wth->fh, &desc_length, 4, err, err_info)) {
				g_hash_table_destroy(comment_table);
				return WTAP_OPEN_ERROR;
			}
			comment_table_size -= 4;

			comment_rec->descLength = pletoh32(&desc_length);
			if (comment_rec->descLength > 0) {
				
				if (comment_rec->descLength > comment_table_size) {
					*err = WTAP_ERR_BAD_FILE;
					*err_info = g_strdup_printf("netmon: comment description size is %u, which is larger than the entire comment section (%d)",
								comment_rec->descLength, comment_table_size);
					g_hash_table_destroy(comment_table);
					return WTAP_OPEN_ERROR;
				}

				comment_rec->description = (guint8*)g_malloc(comment_rec->descLength);

				
				if (!wtap_read_bytes(wth->fh, comment_rec->description, comment_rec->descLength, err, err_info)) {
					g_hash_table_destroy(comment_table);
					return WTAP_OPEN_ERROR;
				}

				comment_table_size -= comment_rec->descLength;
			}
		}
		netmon->comment_table = comment_table;
	}

	if ((process_info_table_offset > 0) && (process_info_table_count > 0)) {
		guint16 version;

		
		if (file_seek(wth->fh, process_info_table_offset, SEEK_SET, err) == -1) {
			return WTAP_OPEN_ERROR;
		}

		process_info_table = g_hash_table_new_full(g_direct_hash, g_direct_equal, NULL, netmonrec_process_info_destroy);
		if (process_info_table == NULL) {
			*err = ENOMEM;	
			return WTAP_OPEN_ERROR;
		}

		
		if (!wtap_read_bytes(wth->fh, &version, 2, err, err_info)) {
			g_hash_table_destroy(process_info_table);
			return WTAP_OPEN_ERROR;
		}

		while (process_info_table_count > 0)
		{
			struct netmonrec_process_info* process_info;
			guint32 tmp32;
			guint16 tmp16;

			process_info = g_new0(struct netmonrec_process_info, 1);

			
			if (!wtap_read_bytes(wth->fh, &tmp32, 4, err, err_info)) {
				g_free(process_info);
				g_hash_table_destroy(process_info_table);
				return WTAP_OPEN_ERROR;
			}

			process_info->pathSize = pletoh32(&tmp32);
			if (process_info->pathSize > 260) {
				*err = WTAP_ERR_BAD_FILE;
				*err_info = g_strdup_printf("netmon: Path size for process info record is %u, which is larger than allowed max value (260)",
							process_info->pathSize);
				g_free(process_info);
				g_hash_table_destroy(process_info_table);
				return WTAP_OPEN_ERROR;
			}

			process_info->path = (guint8*)g_malloc(process_info->pathSize);
			if (!wtap_read_bytes(wth->fh, process_info->path, process_info->pathSize, err, err_info)) {
				g_free(process_info);
				g_hash_table_destroy(process_info_table);
				return WTAP_OPEN_ERROR;
			}

			
			if (!wtap_read_bytes(wth->fh, &tmp32, 4, err, err_info)) {
				g_free(process_info);
				g_hash_table_destroy(process_info_table);
				return WTAP_OPEN_ERROR;
			}

			process_info->iconSize = pletoh32(&tmp32);

			
			if (file_seek(wth->fh, process_info->iconSize, SEEK_CUR, err) == -1) {
				g_free(process_info);
				g_hash_table_destroy(process_info_table);
				return WTAP_OPEN_ERROR;
			}
			process_info->iconSize = 0;

			if (!wtap_read_bytes(wth->fh, &tmp32, 4, err, err_info)) {
				g_free(process_info);
				g_hash_table_destroy(process_info_table);
				return WTAP_OPEN_ERROR;
			}
			process_info->pid = pletoh32(&tmp32);

			
			g_hash_table_insert(process_info_table, GUINT_TO_POINTER(process_info->pid), process_info);

			
			if (!wtap_read_bytes(wth->fh, &tmp16, 2, err, err_info)) {
				g_hash_table_destroy(process_info_table);
				return WTAP_OPEN_ERROR;
			}
			process_info->localPort = pletoh16(&tmp16);

			
			if (!wtap_read_bytes(wth->fh, &tmp16, 2, err, err_info)) {
				g_hash_table_destroy(process_info_table);
				return WTAP_OPEN_ERROR;
			}

			
			if (!wtap_read_bytes(wth->fh, &tmp16, 2, err, err_info)) {
				g_hash_table_destroy(process_info_table);
				return WTAP_OPEN_ERROR;
			}
			process_info->remotePort = pletoh16(&tmp16);

			
			if (!wtap_read_bytes(wth->fh, &tmp16, 2, err, err_info)) {
				g_hash_table_destroy(process_info_table);
				return WTAP_OPEN_ERROR;
			}

			
			if (!wtap_read_bytes(wth->fh, &tmp32, 4, err, err_info)) {
				g_hash_table_destroy(process_info_table);
				return WTAP_OPEN_ERROR;
			}
			process_info->isIPv6 = ((pletoh32(&tmp32) == 0) ? FALSE : TRUE);

			if (process_info->isIPv6) {
				if (!wtap_read_bytes(wth->fh, &process_info->localAddr.ipv6, 16, err, err_info)) {
					g_hash_table_destroy(process_info_table);
					return WTAP_OPEN_ERROR;
				}
				if (!wtap_read_bytes(wth->fh, &process_info->remoteAddr.ipv6, 16, err, err_info)) {
					g_hash_table_destroy(process_info_table);
					return WTAP_OPEN_ERROR;
				}
			} else {
				guint8 ipbuffer[16];
				if (!wtap_read_bytes(wth->fh, ipbuffer, 16, err, err_info)) {
					g_hash_table_destroy(process_info_table);
					return WTAP_OPEN_ERROR;
				}
				process_info->localAddr.ipv4 = pletoh32(ipbuffer);

				if (!wtap_read_bytes(wth->fh, ipbuffer, 16, err, err_info)) {
					g_hash_table_destroy(process_info_table);
					return WTAP_OPEN_ERROR;
				}
				process_info->remoteAddr.ipv4 = pletoh32(ipbuffer);
			}

			process_info_table_count--;
		}

		netmon->process_info_table = process_info_table;
	}

#ifdef WORDS_BIGENDIAN
	


	for (i = 0; i < frame_table_size; i++)
		frame_table[i] = pletoh32(&frame_table[i]);
#endif

	
	netmon->current_frame = 0;
	switch (netmon->version_major) {

	case 1:
		



		wth->file_tsprec = WTAP_TSPREC_MSEC;
		break;

	case 2:
		





		wth->file_tsprec = WTAP_TSPREC_NSEC;
		break;
	}
	return WTAP_OPEN_MINE;
}