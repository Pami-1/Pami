long long Segment::CreateInstance(
    if (result < 0)  
      return result;
 
    if (result > 0)  
      return (pos + 1);
 
    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
      return E_FILE_FORMAT_INVALID;
 
    if ((pos + len) > available)
      return pos + len;
 
    const long long idpos = pos;
    const long long id = ReadUInt(m_pReader, idpos, len);
 
    if (id < 0)  
      return id;

    if (id == 0x0F43B675)  
      break;

    pos += len;  

    if ((pos + 1) > available)
      return (pos + 1);

    
    result = GetUIntLength(m_pReader, pos, len);

    if (result < 0)  
      return result;

    if (result > 0)  
      return (pos + 1);

    if ((segment_stop >= 0) && ((pos + len) > segment_stop))
      return E_FILE_FORMAT_INVALID;

    if ((pos + len) > available)
      return pos + len;

    const long long size = ReadUInt(m_pReader, pos, len);

    if (size < 0)  
      return size;

    pos += len;  

    const long long element_size = size + pos - element_start;

    

    if ((segment_stop >= 0) && ((pos + size) > segment_stop))
      return E_FILE_FORMAT_INVALID;

    

    if ((pos + size) > available)
      return pos + size;

    if (id == 0x0549A966) {  
      if (m_pInfo)
        return E_FILE_FORMAT_INVALID;

      m_pInfo = new (std::nothrow)
          SegmentInfo(this, pos, size, element_start, element_size);

      if (m_pInfo == NULL)
         return -1;
 
      const long status = m_pInfo->Parse();

      if (status)
        return status;
    } else if (id == 0x0654AE6B) {  
      if (m_pTracks)
        return E_FILE_FORMAT_INVALID;

      m_pTracks = new (std::nothrow)
          Tracks(this, pos, size, element_start, element_size);

      if (m_pTracks == NULL)
         return -1;
 
      const long status = m_pTracks->Parse();