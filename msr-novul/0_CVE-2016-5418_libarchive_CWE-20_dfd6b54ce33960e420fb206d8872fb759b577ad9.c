check_symlinks(struct archive_write_disk *a)
check_symlinks_fsobj(char *path, int *error_number, struct archive_string *error_string, int flags)
 {
 #if !defined(HAVE_LSTAT)
 	
 	(void)a; 
	(void)path; 
	(void)error_number; 
	(void)error_string; 
	(void)flags; 
 	return (ARCHIVE_OK);
 #else
	int res = ARCHIVE_OK;
	char *tail;
	char *head;
	int last;
 	char c;
 	int r;
 	struct stat st;
	int restore_pwd;

	
	if(path[0] == '\0')
	    return (ARCHIVE_OK);
 
 	













	restore_pwd = open(".", O_RDONLY | O_BINARY | O_CLOEXEC);
	__archive_ensure_cloexec_flag(restore_pwd);
	if (restore_pwd < 0)
		return (ARCHIVE_FATAL);
	head = path;
	tail = path;
	last = 0;
	
 	
	if(tail == path && tail[0] == '/')
		++tail;
	





	while (!last) {
		
		while (*tail == '/')
		    ++tail;
 		
		while (*tail != '\0' && *tail != '/')
			++tail;
		
		last = (tail[0] == '\0') || (tail[0] == '/' && tail[1] == '\0');
		
		c = tail[0];
		tail[0] = '\0';
 		
		r = lstat(head, &st);
 		if (r != 0) {
			tail[0] = c;
 			
 			if (errno == ENOENT) {
 				break;
 			} else {
				







				if (error_number) *error_number = errno;
				if (error_string)
					archive_string_sprintf(error_string,
							"Could not stat %s",
							path);
				res = ARCHIVE_FAILED;
				break;
			}
		} else if (S_ISDIR(st.st_mode)) {
			if (!last) {
				if (chdir(head) != 0) {
					tail[0] = c;
					if (error_number) *error_number = errno;
					if (error_string)
						archive_string_sprintf(error_string,
								"Could not chdir %s",
								path);
					res = (ARCHIVE_FATAL);
					break;
				}
				
				head = tail + 1;
 			}
 		} else if (S_ISLNK(st.st_mode)) {
			if (last) {
 				




				if (unlink(head)) {
					tail[0] = c;
					if (error_number) *error_number = errno;
					if (error_string)
						archive_string_sprintf(error_string,
								"Could not remove symlink %s",
								path);
					res = ARCHIVE_FAILED;
					break;
 				}
 				





				tail[0] = c;
				








 				
				res = ARCHIVE_OK;
				break;
			} else if (flags & ARCHIVE_EXTRACT_UNLINK) {
 				
				if (unlink(head) != 0) {
					tail[0] = c;
					if (error_number) *error_number = 0;
					if (error_string)
						archive_string_sprintf(error_string,
								"Cannot remove intervening symlink %s",
								path);
					res = ARCHIVE_FAILED;
					break;
 				}
				tail[0] = c;
 			} else {
				tail[0] = c;
				if (error_number) *error_number = 0;
				if (error_string)
					archive_string_sprintf(error_string,
							"Cannot extract through symlink %s",
							path);
				res = ARCHIVE_FAILED;
				break;
 			}
 		}
		
		tail[0] = c;
		if (tail[0] != '\0')
			tail++; 
 	}
	
	tail[0] = c;
#ifdef HAVE_FCHDIR
	
	if (restore_pwd >= 0) {
		r = fchdir(restore_pwd);
		if (r != 0) {
			if(error_number) *error_number = errno;
			if(error_string)
				archive_string_sprintf(error_string,
						"chdir() failure");
		}
		close(restore_pwd);
		restore_pwd = -1;
		if (r != 0) {
			res = (ARCHIVE_FATAL);
		}
	}
#endif
	
	return res;
 #endif
 }