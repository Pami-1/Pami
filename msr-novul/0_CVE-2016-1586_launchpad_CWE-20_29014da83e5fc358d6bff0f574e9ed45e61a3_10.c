void BrowserContextDestroyer::RenderProcessHostDestroyed(
     content::RenderProcessHost* host) {
  DCHECK_GT(pending_host_ids_.size(), 0U);

  size_t erased = pending_host_ids_.erase(host->GetID());
  DCHECK_GT(erased, 0U);

  MaybeScheduleFinishDestroyContext(host);
}


void BrowserContextDestroyer::DestroyContext(
    std::unique_ptr<BrowserContext> context) {
 
  bool has_live_otr_context = false;
  uint32_t otr_contexts_pending_deletion = 0;

  if (!context->IsOffTheRecord()) {
    
    
    
    for (auto* destroyer : g_contexts_pending_deletion.Get()) {
      if (destroyer->context_->IsOffTheRecord() &&
          destroyer->context_->GetOriginalContext() == context.get()) {
        ++otr_contexts_pending_deletion;
      }
    }

    
    
    has_live_otr_context = context->HasOffTheRecordContext();
   } else {
    
    
    
    BrowserContextDestroyer* orig_destroyer =
        GetForContext(context->GetOriginalContext());
    if (orig_destroyer) {
      CHECK(!orig_destroyer->finish_destroy_scheduled_);
      ++orig_destroyer->otr_contexts_pending_deletion_;
    }
  }

  
  std::set<content::RenderProcessHost*> hosts =
      GetHostsForContext(context.get());

  content::BrowserContext::NotifyWillBeDestroyed(context.get());

  
  
  

  if (!hosts.empty() ||
      otr_contexts_pending_deletion > 0 ||
      has_live_otr_context) {
    
    new BrowserContextDestroyer(std::move(context),
                                hosts,
                                otr_contexts_pending_deletion);
   }
 }